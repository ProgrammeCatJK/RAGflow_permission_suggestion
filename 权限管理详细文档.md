# RAGFlow 权限管理系统详细文档

## 目录
1. [系统概述](#系统概述)
2. [核心概念](#核心概念)
3. [前端术语与后端概念对应关系](#前端术语与后端概念对应关系)
4. [权限模型架构](#权限模型架构)
5. [数据库表结构](#数据库表结构)
6. [权限检查机制](#权限检查机制)
7. [实际应用场景](#实际应用场景)
8. [API接口说明](#api接口说明)
9. [代码实现细节](#代码实现细节)
10. [常见问题与排查](#常见问题与排查)

---

## 系统概述

RAGFlow 采用**基于租户（Tenant）的多层级权限管理模型**，结合**基于角色的访问控制（RBAC）**，实现了细粒度的资源访问控制。系统支持多租户架构，每个用户可以属于多个租户，在不同租户中拥有不同的角色和权限。

### 设计特点

- **多租户隔离**：每个租户拥有独立的资源和配置
- **角色分级**：owner、admin、normal、invite 四个角色层级
- **资源权限标记**：me（仅自己）和 team（团队共享）两种权限模式
- **超级用户旁路**：is_superuser 用户可跨租户访问所有资源
- **API Token 认证**：支持通过 API Token 进行程序化访问

---

## 核心概念

### 1. 用户（User）

用户是系统的基本实体，每个用户拥有唯一的用户ID和邮箱。

**关键字段：**
- `id`：用户唯一标识（通常等于邮箱或用户ID）
- `email`：用户邮箱，用于登录
- `password`：加密存储的密码
- `is_superuser`：**超级用户标志**，设置为 `True` 时拥有系统所有权限，可跨租户访问所有资源
- `status`：用户状态（'0'=禁用，'1'=启用）
- `is_active`：用户活跃状态（'0'=不活跃，'1'=活跃）

**实际例子：**
```python
# 普通用户
user = {
    "id": "zhangsan@example.com",
    "email": "zhangsan@example.com",
    "is_superuser": False,
    "status": "1",
    "is_active": "1"
}

# 超级用户（系统管理员）
admin = {
    "id": "admin@ragflow.io",
    "email": "admin@ragflow.io",
    "is_superuser": True,  # 关键：超级用户标志
    "status": "1",
    "is_active": "1"
}
```

### 2. 租户（Tenant）

租户是资源隔离的逻辑工作区，每个租户拥有独立的：
- 知识库（Knowledgebase）
- 文档（File）
- 智能体（Agent）
- 默认模型配置（LLM、向量模型、解析器等）

**关键字段：**
- `id`：租户唯一标识（通常等于创建者的用户ID）
- `name`：租户名称
- `llm_id`：默认LLM模型ID
- `embd_id`：默认向量模型ID
- `status`：租户状态（'0'=禁用，'1'=启用）

**实际例子：**
```python
# 研发部门租户
dev_tenant = {
    "id": "dev_team_001",
    "name": "研发部门",
    "llm_id": "gpt-4@openai",
    "embd_id": "text-embedding-ada-002@openai",
    "status": "1"
}

# 市场部门租户
market_tenant = {
    "id": "market_team_001",
    "name": "市场部门",
    "llm_id": "gpt-3.5-turbo@openai",
    "embd_id": "text-embedding-ada-002@openai",
    "status": "1"
}
```

### 3. 用户-租户关系（UserTenant）

UserTenant 表建立了用户与租户之间的多对多关系，并定义了用户在租户中的角色。

**关键字段：**
- `id`：关系唯一标识
- `user_id`：用户ID
- `tenant_id`：租户ID
- `role`：用户在租户中的角色（**核心字段**）
- `invited_by`：邀请者用户ID
- `status`：关系状态（'0'=无效，'1'=有效）

**角色类型（UserTenantRole）：**

| 角色 | 值 | 权限说明 | 实际场景 |
|------|-----|---------|---------|
| **owner** | 'owner' | 租户创建者，拥有所有权限，可管理成员、资源和配置 | 公司CEO创建了公司租户，成为owner |
| **admin** | 'admin' | 团队管理员，可创建/管理资源，但不能删除Owner | 研发经理被CEO任命为admin，可管理研发团队 |
| **normal** | 'normal' | 普通成员，仅能访问被允许的团队资源 | 研发工程师加入团队，成为normal成员 |
| **invite** | 'invite' | 待接受的邀请记录，尚无实际访问权 | 新员工收到邀请但尚未接受，状态为invite |

**实际例子：**
```python
# 张三在研发部门的角色关系
user_tenant_1 = {
    "id": "ut_001",
    "user_id": "zhangsan@example.com",
    "tenant_id": "dev_team_001",
    "role": "owner",  # 张三是研发部门的创建者
    "invited_by": "zhangsan@example.com",
    "status": "1"
}

# 李四在研发部门的角色关系
user_tenant_2 = {
    "id": "ut_002",
    "user_id": "lisi@example.com",
    "tenant_id": "dev_team_001",
    "role": "admin",  # 李四是研发部门的管理员
    "invited_by": "zhangsan@example.com",
    "status": "1"
}

# 王五在研发部门的角色关系
user_tenant_3 = {
    "id": "ut_003",
    "user_id": "wangwu@example.com",
    "tenant_id": "dev_team_001",
    "role": "normal",  # 王五是研发部门的普通成员
    "invited_by": "lisi@example.com",
    "status": "1"
}

# 赵六收到邀请但未接受
user_tenant_4 = {
    "id": "ut_004",
    "user_id": "zhaoliu@example.com",
    "tenant_id": "dev_team_001",
    "role": "invite",  # 赵六尚未接受邀请
    "invited_by": "lisi@example.com",
    "status": "1"
}
```

### 4. 资源权限标记（TenantPermission）

资源（知识库、文件等）通过 `permission` 字段控制访问范围。

**权限类型：**

| 权限值 | 说明 | 实际效果 |
|--------|------|---------|
| **me** | 仅创建者本人可见 | 只有资源创建者和超级用户可以访问 |
| **team** | 同一租户的所有成员可见 | 租户内所有非invite角色的成员都可以访问 |

**实际例子：**
```python
# 知识库：产品需求文档（团队共享）
kb_team = {
    "id": "kb_001",
    "name": "产品需求文档",
    "tenant_id": "dev_team_001",
    "permission": "team",  # 团队共享
    "status": "1"
}
# 效果：研发部门的所有成员（owner/admin/normal）都可以访问

# 知识库：个人笔记（仅自己可见）
kb_me = {
    "id": "kb_002",
    "name": "张三的个人笔记",
    "tenant_id": "dev_team_001",
    "permission": "me",  # 仅自己可见
    "status": "1"
}
# 效果：只有张三本人和超级用户可以访问
```

---

## 前端术语与后端概念对应关系

### 重要说明

在前端界面中，您会看到"工作空间"和"团队"等术语，这些术语与后端的数据库概念有明确的对应关系。理解这些对应关系对于理解整个权限管理系统至关重要。

### 术语对照表

| 前端显示术语 | 后端数据库概念 | 英文标识 | 说明 |
|------------|--------------|---------|------|
| **工作空间** | **租户（Tenant）** | Workspace / Tenant | 用户当前所在的工作环境 |
| **团队** | **租户列表（Tenant List）** | Team | 用户加入的所有租户 |
| **团队成员** | **租户用户列表（Tenant Users）** | Team Members | 当前工作空间下的所有用户 |
| **用户** | **用户（User）** | User | 系统的基本实体 |

### 详细说明

#### 1. 工作空间（Workspace）= 租户（Tenant）

**前端显示：**
- 个人信息设置页显示："张三的工作空间"
- 通过 `useFetchTenantInfo()` 获取当前工作空间信息

**后端实现：**
- 对应数据库表：`tenant`
- 每个租户就是一个工作空间
- 用户创建租户时，该租户的 `id` 通常等于用户的 `id`

**实际例子：**
```typescript
// 前端获取当前工作空间
const { data: tenantInfo } = useFetchTenantInfo();
// tenantInfo 包含：
// {
//   tenant_id: "zhangsan@example.com",  // 工作空间ID
//   name: "研发部门",                    // 工作空间名称
//   llm_id: "gpt-4@openai",             // 默认LLM模型
//   embd_id: "text-embedding-ada-002@openai", // 默认向量模型
//   role: "owner"                        // 用户在该工作空间中的角色
// }
```

**关键特点：**
- 每个用户至少有一个工作空间（自己创建的）
- 用户可以切换工作空间（切换租户）
- 工作空间拥有独立的资源（知识库、文档、智能体等）
- 工作空间拥有独立的模型配置（LLM、向量模型等）

#### 2. 团队（Team）= 用户加入的所有租户列表

**前端显示：**
- 个人信息设置页显示："已加入的团队"（joinedTeams）
- 通过 `useListTenant()` 获取用户加入的所有团队

**后端实现：**
- 对应数据库表：`user_tenant`（用户-租户关系表）
- 查询用户作为 owner、admin、normal 或 invite 角色的所有租户

**实际例子：**
```typescript
// 前端获取用户加入的所有团队
const { data: tenants } = useListTenant();
// tenants 是一个数组，包含：
// [
//   {
//     tenant_id: "zhangsan@example.com",  // 团队ID（工作空间ID）
//     nickname: "张三",                    // 团队创建者昵称
//     email: "zhangsan@example.com",      // 团队创建者邮箱
//     role: "owner",                      // 用户在该团队中的角色
//     update_date: "2024-01-01"          // 更新时间
//   },
//   {
//     tenant_id: "dev_team_001",
//     nickname: "李四",
//     email: "lisi@example.com",
//     role: "normal",                    // 用户作为普通成员加入
//     update_date: "2024-01-15"
//   }
// ]
```

**关键特点：**
- 团队列表包括用户创建的所有租户（role=owner）
- 团队列表包括用户加入的所有租户（role=admin/normal）
- 团队列表包括用户收到的邀请（role=invite，尚未接受）
- 用户可以在不同团队中拥有不同的角色

#### 3. 团队成员（Team Members）= 当前工作空间的用户列表

**前端显示：**
- 个人信息设置页显示："团队成员"（teamMembers）
- 通过 `useListTenantUser()` 获取当前工作空间的所有成员

**后端实现：**
- 对应数据库表：`user_tenant`（用户-租户关系表）
- 查询当前租户（tenant_id）下的所有用户及其角色

**实际例子：**
```typescript
// 前端获取当前工作空间的团队成员
const { data: tenantInfo } = useFetchTenantInfo();
const { data: users } = useListTenantUser();
// users 是一个数组，包含当前工作空间的所有成员：
// [
//   {
//     user_id: "zhangsan@example.com",
//     nickname: "张三",
//     email: "zhangsan@example.com",
//     role: "owner",                     // 工作空间创建者
//     avatar: "...",
//     is_active: "1"
//   },
//   {
//     user_id: "lisi@example.com",
//     nickname: "李四",
//     email: "lisi@example.com",
//     role: "admin",                     // 管理员
//     avatar: "...",
//     is_active: "1"
//   },
//   {
//     user_id: "wangwu@example.com",
//     nickname: "王五",
//     email: "wangwu@example.com",
//     role: "normal",                   // 普通成员
//     avatar: "...",
//     is_active: "1"
//   }
// ]
```

**关键特点：**
- 团队成员列表只显示当前工作空间（当前租户）的用户
- 每个成员都有明确的角色（owner/admin/normal/invite）
- owner 可以管理所有成员（添加、删除、修改角色）
- admin 可以管理 normal 成员，但不能删除 owner

### Normal 角色权限详解

**Normal 角色（普通成员/Member）的权限范围：**

#### 1. 知识库（Knowledgebase/Dataset）操作权限

| 操作 | 权限 | 说明 |
|------|------|------|
| **创建知识库** | ✅ 可以 | 可以在当前工作空间创建新的知识库 |
| **查看知识库** | ✅ 可以 | 可以查看权限为 `team` 的知识库，或自己创建的知识库 |
| **修改知识库** | ❌ 不可以 | 只有知识库的创建者可以修改（名称、描述、解析器等） |
| **删除知识库** | ❌ 不可以 | 只有知识库的创建者可以删除 |

**代码依据：**
```python
# api/db/services/knowledgebase_service.py
def accessible4deletion(cls, kb_id, user_id):
    """只有创建者可以删除或修改知识库"""
    docs = cls.model.select(cls.model.id).where(
        cls.model.id == kb_id, 
        cls.model.created_by == user_id  # 必须是创建者
    )
    return len(docs) > 0
```

**实际例子：**
- ✅ 王五（normal）可以在工作空间创建新知识库"产品文档"
- ✅ 王五可以查看李四创建的、权限为 `team` 的知识库"技术规范"
- ❌ 王五不能修改"技术规范"知识库的名称或配置
- ❌ 王五不能删除"技术规范"知识库

#### 2. 文档（Document）操作权限

| 操作 | 权限 | 说明 |
|------|------|------|
| **上传文档** | ✅ 可以 | 可以向权限为 `team` 的知识库上传文档，或向自己创建的知识库上传 |
| **查看文档** | ✅ 可以 | 可以查看权限为 `team` 的知识库中的文档 |
| **删除文档** | ✅ 可以 | **可以删除文档**，但有限制条件（见下方说明） |
| **解析文档** | ✅ 可以 | 可以触发文档解析任务 |
| **修改文档状态** | ✅ 可以 | 可以修改文档的解析状态 |

**代码依据：**
```python
# api/db/services/document_service.py
def accessible4deletion(cls, doc_id, user_id):
    """normal 和 owner 都可以删除文档"""
    docs = cls.model.select(cls.model.id).join(
        Knowledgebase, on=(Knowledgebase.id == cls.model.kb_id)
    ).join(
        UserTenant, on=(
            (UserTenant.tenant_id == Knowledgebase.created_by) & 
            (UserTenant.user_id == user_id)
        )
    ).where(
        cls.model.id == doc_id,
        UserTenant.status == StatusEnum.VALID.value,
        ((UserTenant.role == UserTenantRole.NORMAL) | 
         (UserTenant.role == UserTenantRole.OWNER))  # normal 可以删除
    )
    return len(docs) > 0
```

**重要说明：** Normal 用户可以删除文档，但有一个重要条件：
- 文档所属的知识库的创建者（`Knowledgebase.created_by`）必须是用户所在的租户
- 这意味着：如果知识库是工作空间创建者（owner）创建的，那么 normal 用户可以删除其中的文档
- 但如果知识库是其他用户创建的，normal 用户可能无法删除其中的文档

**实际例子：**
- ✅ 王五（normal）可以向"技术规范"知识库（team权限）上传文档
- ✅ 王五可以查看"技术规范"知识库中的所有文档
- ✅ 王五可以删除"技术规范"知识库中的文档（如果知识库是工作空间owner创建的）
- ✅ 王五可以触发文档解析任务

#### 3. 文件（File）操作权限

| 操作 | 权限 | 说明 |
|------|------|------|
| **上传文件** | ✅ 可以 | 可以上传文件到工作空间 |
| **查看文件** | ✅ 可以 | 可以查看权限为 `team` 的文件，或自己创建的文件 |
| **删除文件** | ✅ 可以 | 可以删除自己有权限访问的文件 |
| **重命名文件** | ✅ 可以 | 可以重命名自己有权限访问的文件 |

**代码依据：**
```python
# api/apps/file_app.py
@manager.route("/rm", methods=["POST"])
@login_required
async def rm():
    # 检查文件权限
    if not check_file_team_permission(file, current_user.id):
        return get_json_result(
            data=False, 
            message="No authorization.", 
            code=RetCode.AUTHENTICATION_ERROR
        )
    # 可以删除
```

#### 4. 工作空间管理权限

| 操作 | 权限 | 说明 |
|------|------|------|
| **查看工作空间配置** | ✅ 可以 | 可以查看工作空间的模型配置等 |
| **修改工作空间配置** | ❌ 不可以 | 只有 owner 可以修改工作空间配置 |
| **管理团队成员** | ❌ 不可以 | 不能添加、删除或修改团队成员 |
| **退出工作空间** | ✅ 可以 | 可以退出自己加入的工作空间 |

#### 5. 其他操作权限

| 操作 | 权限 | 说明 |
|------|------|------|
| **创建智能体（Agent）** | ✅ 可以 | 可以在工作空间创建智能体 |
| **使用聊天功能** | ✅ 可以 | 可以使用聊天功能查询知识库 |
| **查看搜索历史** | ✅ 可以 | 可以查看自己的搜索历史 |

### Normal 角色权限总结

**Normal 角色可以做的事情：**
1. ✅ 创建知识库、文档、智能体等资源
2. ✅ 查看和访问团队共享的资源（permission=team）
3. ✅ 上传、删除文档和文件（在权限范围内）
4. ✅ 使用所有业务功能（聊天、搜索等）
5. ✅ 退出工作空间

**Normal 角色不能做的事情：**
1. ❌ 修改或删除他人创建的知识库
2. ❌ 修改工作空间配置（模型、解析器等）
3. ❌ 管理团队成员（添加、删除、修改角色）
4. ❌ 删除工作空间

### 权限对比表

| 操作 | Owner | Admin | Normal | Invite |
|------|-------|-------|--------|--------|
| 创建知识库 | ✅ | ✅ | ✅ | ❌ |
| 删除知识库（自己创建的） | ✅ | ✅ | ✅ | ❌ |
| 删除知识库（他人创建的） | ❌ | ❌ | ❌ | ❌ |
| 修改知识库（自己创建的） | ✅ | ✅ | ✅ | ❌ |
| 修改知识库（他人创建的） | ❌ | ❌ | ❌ | ❌ |
| 上传文档 | ✅ | ✅ | ✅ | ❌ |
| 删除文档 | ✅ | ✅ | ✅* | ❌ |
| 管理团队成员 | ✅ | ✅ | ❌ | ❌ |
| 修改工作空间配置 | ✅ | ❌ | ❌ | ❌ |
| 删除工作空间 | ✅ | ❌ | ❌ | ❌ |

*注：Normal 可以删除文档，但需要满足特定条件（见上方说明）

**前端角色显示说明：**
在前端界面中，团队成员的角色显示规则如下：

| 后端角色值 | 前端显示 | 说明 |
|-----------|---------|------|
| `owner` | **Owner** | 工作空间创建者，拥有所有权限 |
| `admin` | **Admin** | 团队管理员，可管理资源和成员 |
| `normal` | **Member** | 普通成员，仅能访问被允许的资源 |
| `invite` | **Invite** | 待接受的邀请，尚无访问权限 |

**注意：** 前端代码中，`normal` 角色会被显示为 "Member"（成员），而不是 "Normal"。这是为了更好的用户体验，因为 "Member" 比 "Normal" 更直观易懂。

**代码实现：**
```typescript
// web/src/pages/user-setting/setting-team/user-table.tsx
{record.role === TenantRole.Normal && (
  <Badge className={ColorMap[record.role]}>
    {upperFirst('Member')}  // normal 角色显示为 "Member"
  </Badge>
)}
{record.role !== TenantRole.Normal && (
  <Badge className={ColorMap[record.role]}>
    {upperFirst(record.role)}  // 其他角色直接显示角色名
  </Badge>
)}
```

### 概念关系图

```
┌─────────────────────────────────────────────────────────┐
│                     用户（User）                         │
│                  zhangsan@example.com                   │
└──────────────────────┬──────────────────────────────────┘
                       │
                       │ 可以创建或加入多个
                       │
        ┌──────────────┴──────────────┐
        │                             │
        ▼                             ▼
┌───────────────┐            ┌───────────────┐
│  工作空间1     │            │  工作空间2     │
│  (租户1)       │            │  (租户2)       │
│  tenant_id:    │            │  tenant_id:    │
│  zhangsan@...  │            │  dev_team_001   │
│  role: owner   │            │  role: normal   │
└───────┬───────┘            └───────┬───────┘
        │                             │
        │ 当前工作空间                 │ 已加入的团队
        │ (当前租户)                   │ (其他租户)
        │                             │
        ▼                             ▼
┌───────────────┐            ┌───────────────┐
│  团队成员列表   │            │  团队列表      │
│  (当前租户的    │            │  (用户加入的   │
│   所有用户)    │            │   所有租户)    │
│                │            │                │
│ - 张三(owner)  │            │ - 工作空间1     │
│ - 李四(admin) │            │ - 工作空间2     │
│ - 王五(normal)│            │ - 工作空间3     │
└────────────────┘            └────────────────┘
```

### 实际场景示例

#### 场景1：用户张三的工作空间和团队

**用户信息：**
- 用户ID：`zhangsan@example.com`
- 昵称：张三

**工作空间（当前租户）：**
- 工作空间ID：`zhangsan@example.com`（自己创建的）
- 工作空间名称：张三的工作空间
- 角色：owner（创建者）

**团队列表（用户加入的所有租户）：**
1. **工作空间1**（自己创建的）
   - tenant_id: `zhangsan@example.com`
   - role: `owner`
   - 创建时间：2024-01-01

2. **工作空间2**（加入的）
   - tenant_id: `dev_team_001`
   - role: `admin`
   - 加入时间：2024-01-15

3. **工作空间3**（收到邀请，未接受）
   - tenant_id: `market_team_001`
   - role: `invite`
   - 邀请时间：2024-01-20

**当前工作空间的团队成员：**
- 张三（owner）- 工作空间创建者
- 李四（admin）- 管理员
- 王五（normal）- 普通成员
- 赵六（invite）- 收到邀请但未接受

#### 场景2：切换工作空间

**操作流程：**
1. 用户在个人信息设置页查看"已加入的团队"列表
2. 用户选择要切换的工作空间（租户）
3. 系统更新当前工作空间（tenant_id）
4. 页面刷新，显示新工作空间的资源和配置

**代码实现（伪代码）：**
```typescript
// 切换工作空间
const switchWorkspace = async (tenantId: string) => {
  // 1. 更新当前工作空间
  await setCurrentTenant(tenantId);
  
  // 2. 刷新工作空间信息
  queryClient.invalidateQueries({ queryKey: ['tenantInfo'] });
  
  // 3. 刷新团队成员列表
  queryClient.invalidateQueries({ queryKey: ['listTenantUser'] });
  
  // 4. 刷新资源列表（知识库、文档等）
  queryClient.invalidateQueries({ queryKey: ['datasets'] });
};
```

**实际效果：**
- 切换前：显示工作空间1的知识库和文档
- 切换后：显示工作空间2的知识库和文档
- 团队成员列表也会相应更新

### 前端页面结构

**个人信息设置页（/user-setting/team）包含：**

1. **页面标题**
   - 显示："张三的工作空间"（`{nickname} + ' ' + t('setting.workspace')`）

2. **团队成员卡片**
   - 标题："团队成员"（`t('setting.teamMembers')`）
   - 内容：当前工作空间的所有成员列表
   - 操作：邀请新成员、删除成员、查看成员角色

3. **已加入的团队卡片**
   - 标题："已加入的团队"（`t('setting.joinedTeams')`）
   - 内容：用户加入的所有租户列表
   - 操作：接受/拒绝邀请、退出团队、切换工作空间

### 数据流向

```
用户登录
    │
    ▼
获取用户信息 (useFetchUserInfo)
    │
    ▼
获取当前工作空间信息 (useFetchTenantInfo)
    │
    ├─→ 显示工作空间名称
    ├─→ 获取工作空间配置（模型等）
    └─→ 获取团队成员列表 (useListTenantUser)
            │
            └─→ 显示团队成员表格
                    │
                    ├─→ 显示成员角色（owner/admin/normal/invite）
                    └─→ 提供管理操作（添加/删除成员）

获取团队列表 (useListTenant)
    │
    └─→ 显示已加入的团队表格
            │
            ├─→ 显示团队信息（创建者、加入时间等）
            ├─→ 显示用户在团队中的角色
            └─→ 提供操作（接受邀请、退出团队、切换工作空间）
```

### 总结

**核心理解：**
1. **工作空间 = 租户**：用户当前所在的工作环境，拥有独立的资源和配置
2. **团队 = 租户列表**：用户加入的所有租户，包括自己创建的和加入的
3. **团队成员 = 租户用户**：当前工作空间下的所有用户及其角色
4. **用户**：系统的基本实体，可以创建或加入多个工作空间（租户）

**关键点：**
- 一个用户可以属于多个租户（工作空间）
- 每个租户就是一个工作空间
- 用户在不同租户中可以拥有不同的角色
- 当前工作空间决定了用户看到的资源和配置
- 团队成员列表只显示当前工作空间的用户

---

## 权限模型架构

### 权限关系图

```
┌─────────┐
│  User   │ (用户)
└────┬────┘
     │
     │ 多对多关系
     │
┌────▼──────────────┐
│   UserTenant      │ (用户-租户关系)
│  - user_id        │
│  - tenant_id      │
│  - role           │ ← 关键：owner/admin/normal/invite
└────┬──────────────┘
     │
     │ 关联到
     │
┌────▼─────────┐
│   Tenant     │ (租户)
└────┬─────────┘
     │
     │ 拥有
     │
┌────▼──────────────┐
│  Knowledgebase    │ (知识库)
│  - tenant_id      │
│  - permission     │ ← 关键：me/team
└────┬──────────────┘
     │
     │ 包含
     │
┌────▼─────┐
│   File   │ (文件)
│  - tenant_id │
└──────────┘
```

### 权限检查逻辑

#### 1. 超级用户检查（最高优先级）

```python
# 伪代码
if user.is_superuser:
    return True  # 超级用户可以直接访问所有资源
```

**实际例子：**
- 系统管理员（admin@ragflow.io）设置了 `is_superuser=True`
- 即使不属于某个租户，也可以访问该租户的所有资源
- 用于系统维护、数据恢复等场景

#### 2. 租户成员检查

```python
# 伪代码
def check_access(user_id, resource):
    # 1. 检查用户是否属于资源的租户
    user_tenants = get_user_tenants(user_id)
    if resource.tenant_id not in [ut.tenant_id for ut in user_tenants]:
        return False
    
    # 2. 检查用户角色（invite角色无访问权）
    user_tenant = get_user_tenant(user_id, resource.tenant_id)
    if user_tenant.role == "invite":
        return False
    
    # 3. 检查资源权限标记
    if resource.permission == "me":
        # 仅创建者可以访问
        return resource.creator_id == user_id
    elif resource.permission == "team":
        # 租户内所有成员都可以访问
        return True
    
    return False
```

#### 3. 知识库权限检查（实际代码）

参考 `api/common/check_team_permission.py`：

```python
def check_kb_team_permission(kb: dict | Knowledgebase, user_id: str) -> bool:
    """
    检查用户是否有权限访问知识库
    
    参数:
        kb: 知识库对象或字典
        user_id: 用户ID
    
    返回:
        bool: True表示有权限，False表示无权限
    """
    kb = kb.to_dict() if isinstance(kb, Knowledgebase) else kb
    
    kb_tenant_id = kb["tenant_id"]
    
    # 情况1：用户是知识库所属租户的创建者（owner）
    if kb_tenant_id == user_id:
        return True
    
    # 情况2：知识库权限为team，且用户是该租户的成员
    if kb["permission"] != TenantPermission.TEAM:
        return False
    
    # 获取用户加入的所有租户
    joined_tenants = TenantService.get_joined_tenants_by_user_id(user_id)
    return any(tenant["tenant_id"] == kb_tenant_id for tenant in joined_tenants)
```

**实际例子：**

**场景1：张三访问自己的私有知识库**
```python
kb = {
    "id": "kb_001",
    "tenant_id": "dev_team_001",  # 张三创建的租户
    "permission": "me",
    "creator_id": "zhangsan@example.com"
}

user_id = "zhangsan@example.com"

# 检查流程：
# 1. kb_tenant_id == user_id? → True（张三就是租户创建者）
# 结果：✅ 有权限
```

**场景2：李四访问团队共享的知识库**
```python
kb = {
    "id": "kb_002",
    "tenant_id": "dev_team_001",
    "permission": "team",  # 团队共享
    "creator_id": "zhangsan@example.com"
}

user_id = "lisi@example.com"  # 李四是研发部门的admin

# 检查流程：
# 1. kb_tenant_id == user_id? → False
# 2. permission == "team"? → True
# 3. 查询UserTenant表，确认李四属于dev_team_001租户 → True
# 结果：✅ 有权限
```

**场景3：王五访问私有知识库（非创建者）**
```python
kb = {
    "id": "kb_003",
    "tenant_id": "dev_team_001",
    "permission": "me",  # 仅创建者可见
    "creator_id": "zhangsan@example.com"
}

user_id = "wangwu@example.com"  # 王五是normal成员

# 检查流程：
# 1. kb_tenant_id == user_id? → False
# 2. permission == "team"? → False（是"me"）
# 结果：❌ 无权限
```

**场景4：赵六访问知识库（invite状态）**
```python
kb = {
    "id": "kb_002",
    "tenant_id": "dev_team_001",
    "permission": "team",
    "creator_id": "zhangsan@example.com"
}

user_id = "zhaoliu@example.com"  # 赵六的role是"invite"

# 检查流程：
# 1. kb_tenant_id == user_id? → False
# 2. permission == "team"? → True
# 3. 查询UserTenant表，发现role="invite" → 无访问权
# 结果：❌ 无权限（即使知识库是team共享的）
```

#### 4. 文件权限检查

文件权限继承自所属知识库的权限：

```python
def check_file_team_permission(file: dict | File, user_id: str) -> bool:
    """
    检查用户是否有权限访问文件
    
    文件权限继承自所属知识库的权限
    """
    file = file.to_dict() if isinstance(file, File) else file
    
    file_tenant_id = file["tenant_id"]
    if file_tenant_id == user_id:
        return True
    
    file_id = file["id"]
    
    # 获取文件所属的所有知识库
    kb_ids = [kb_info["kb_id"] for kb_info in FileService.get_kb_id_by_file_id(file_id)]
    
    # 检查文件所属的任一知识库是否有权限
    for kb_id in kb_ids:
        ok, kb = KnowledgebaseService.get_by_id(kb_id)
        if not ok:
            continue
        
        if check_kb_team_permission(kb, user_id):
            return True
    
    return False
```

**实际例子：**
```python
# 文件属于"产品需求文档"知识库
file = {
    "id": "file_001",
    "name": "需求规格说明书.pdf",
    "tenant_id": "dev_team_001"
}

# 知识库配置
kb = {
    "id": "kb_001",
    "name": "产品需求文档",
    "tenant_id": "dev_team_001",
    "permission": "team"  # 团队共享
}

# 李四访问文件
user_id = "lisi@example.com"

# 检查流程：
# 1. 文件属于kb_001知识库
# 2. 检查kb_001的权限 → team共享
# 3. 检查李四是否有权限访问kb_001 → True（李四是admin）
# 结果：✅ 有权限访问文件
```

---

## 数据库表结构

### 核心表说明

RAGFlow 系统使用以下核心数据库表来管理用户、租户、资源和权限：

| 实体 | 数据库表名 | 说明 |
|------|-----------|------|
| **用户** | `user` | 存储用户账号信息 |
| **租户** | `tenant` | 存储工作空间（租户）信息 |
| **用户-租户关系** | `user_tenant` | 存储用户在租户中的角色（核心权限表） |
| **知识库** | `knowledgebase` | 存储知识库（数据集）信息 |
| **文档** | `document` | 存储文档信息 |
| **文件** | `file` | 存储文件信息 |

### 1. User 表（用户表）

**表名：** `user`  
**对应实体：** 用户账号

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | CharField(32) | 用户唯一标识（主键） | "user_123" |
| `email` | CharField(255) | 用户邮箱（唯一，用于登录） | "zhangsan@example.com" |
| `password` | CharField(255) | 加密密码 | "hashed_password" |
| `nickname` | CharField(100) | 昵称 | "张三" |
| `avatar` | TextField | 头像（base64编码） | "data:image/png;base64..." |
| `language` | CharField(32) | 语言偏好 | "Chinese" / "English" |
| `color_schema` | CharField(32) | 主题颜色 | "Bright" / "Dark" |
| `timezone` | CharField(64) | 时区 | "UTC+8\tAsia/Shanghai" |
| `last_login_time` | DateTimeField | 最后登录时间 | "2024-01-01 10:00:00" |
| `access_token` | CharField(255) | 访问令牌 | "token_string" |
| `is_authenticated` | CharField(1) | 是否已认证 | "1"（是） |
| `is_active` | CharField(1) | 是否活跃 | "1"（活跃） |
| `is_anonymous` | CharField(1) | 是否匿名 | "0"（否） |
| `login_channel` | CharField | 登录渠道 | "password" |
| `status` | CharField(1) | 用户状态 | "1"（启用）/ "0"（禁用） |
| `is_superuser` | BooleanField | **超级用户标志** | False / True |
| `create_time` | BigIntegerField | 创建时间戳 | 1704067200 |
| `create_date` | DateTimeField | 创建日期 | "2024-01-01 00:00:00" |
| `update_time` | BigIntegerField | 更新时间戳 | 1704067200 |
| `update_date` | DateTimeField | 更新日期 | "2024-01-01 00:00:00" |

**关键字段说明：**
- `id`：用户唯一标识，通常等于用户ID
- `is_superuser`：设置为 `True` 时，用户拥有系统所有权限，可跨租户访问所有资源
- `status`：'0'=禁用，'1'=启用
- `is_active`：'0'=不活跃，'1'=活跃

**SQL示例：**
```sql
CREATE TABLE user (
    id VARCHAR(32) PRIMARY KEY,
    email VARCHAR(255) NOT NULL,
    password VARCHAR(255),
    nickname VARCHAR(100) NOT NULL,
    avatar TEXT,
    language VARCHAR(32),
    color_schema VARCHAR(32),
    timezone VARCHAR(64),
    last_login_time DATETIME,
    access_token VARCHAR(255),
    is_authenticated CHAR(1) DEFAULT '1',
    is_active CHAR(1) DEFAULT '1',
    is_anonymous CHAR(1) DEFAULT '0',
    login_channel VARCHAR(255),
    status CHAR(1) DEFAULT '1',
    is_superuser BOOLEAN DEFAULT FALSE,
    create_time BIGINT,
    create_date DATETIME,
    update_time BIGINT,
    update_date DATETIME,
    INDEX idx_email (email),
    INDEX idx_is_superuser (is_superuser),
    INDEX idx_status (status)
);
```

### 2. Tenant 表（租户表）

**表名：** `tenant`  
**对应实体：** 工作空间（租户）

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | CharField(32) | 租户唯一标识（主键） | "user_123"（通常等于创建者用户ID） |
| `name` | CharField(100) | 租户名称 | "张三's Kingdom" |
| `public_key` | CharField(255) | 公钥 | "public_key_string" |
| `llm_id` | CharField(128) | 默认LLM模型ID | "gpt-4@openai" |
| `embd_id` | CharField(128) | 默认向量模型ID | "text-embedding-ada-002@openai" |
| `asr_id` | CharField(128) | 默认ASR模型ID | "whisper@openai" |
| `img2txt_id` | CharField(128) | 默认图像转文本模型ID | "gpt-4v@openai" |
| `rerank_id` | CharField(128) | 默认重排序模型ID | "BAAI/bge-reranker-v2-m3" |
| `tts_id` | CharField(256) | 默认TTS模型ID | "tts_model_id" |
| `parser_ids` | CharField(256) | 文档解析器列表 | "naive,qa,tag" |
| `credit` | IntegerField | 积分/配额 | 512 |
| `status` | CharField(1) | 租户状态 | "1"（启用）/ "0"（禁用） |
| `create_time` | BigIntegerField | 创建时间戳 | 1704067200 |
| `create_date` | DateTimeField | 创建日期 | "2024-01-01 00:00:00" |
| `update_time` | BigIntegerField | 更新时间戳 | 1704067200 |
| `update_date` | DateTimeField | 更新日期 | "2024-01-01 00:00:00" |

**关键字段说明：**
- `id`：租户唯一标识，通常等于创建者的用户ID
- `name`：租户名称，注册时自动设置为 `"{nickname}'s Kingdom"`
- `llm_id`、`embd_id` 等：工作空间的默认模型配置
- `credit`：积分/配额，用于资源使用限制

**SQL示例：**
```sql
CREATE TABLE tenant (
    id VARCHAR(32) PRIMARY KEY,
    name VARCHAR(100),
    public_key VARCHAR(255),
    llm_id VARCHAR(128) NOT NULL,
    embd_id VARCHAR(128) NOT NULL,
    asr_id VARCHAR(128) NOT NULL,
    img2txt_id VARCHAR(128) NOT NULL,
    rerank_id VARCHAR(128) NOT NULL,
    tts_id VARCHAR(256),
    parser_ids VARCHAR(256) NOT NULL,
    credit INT DEFAULT 512,
    status CHAR(1) DEFAULT '1',
    create_time BIGINT,
    create_date DATETIME,
    update_time BIGINT,
    update_date DATETIME,
    INDEX idx_status (status)
);
```

### 3. UserTenant 表（用户-租户关系表，核心权限表）

**表名：** `user_tenant`  
**对应实体：** 用户在租户中的角色关系

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | CharField(32) | 关系唯一标识（主键） | "ut_001" |
| `user_id` | CharField(32) | 用户ID（外键→user.id） | "user_123" |
| `tenant_id` | CharField(32) | 租户ID（外键→tenant.id） | "user_123" |
| `role` | CharField(32) | **用户角色**（核心字段） | "owner" / "admin" / "normal" / "invite" |
| `invited_by` | CharField(32) | 邀请者用户ID | "user_456" |
| `status` | CharField(1) | 关系状态 | "1"（有效）/ "0"（无效） |
| `create_time` | BigIntegerField | 创建时间戳 | 1704067200 |
| `create_date` | DateTimeField | 创建日期 | "2024-01-01 00:00:00" |
| `update_time` | BigIntegerField | 更新时间戳 | 1704067200 |
| `update_date` | DateTimeField | 更新日期 | "2024-01-01 00:00:00" |

**关键字段说明：**
- `role`：用户在租户中的角色，决定用户权限
  - `owner`：租户创建者，拥有所有权限
  - `admin`：团队管理员，可管理资源和成员
  - `normal`：普通成员，可访问团队资源
  - `invite`：待接受的邀请，无访问权限
- `status`：'0'=无效，'1'=有效

**SQL示例：**
```sql
CREATE TABLE user_tenant (
    id VARCHAR(32) PRIMARY KEY,
    user_id VARCHAR(32) NOT NULL,
    tenant_id VARCHAR(32) NOT NULL,
    role VARCHAR(32) NOT NULL,  -- owner/admin/normal/invite
    invited_by VARCHAR(32) NOT NULL,
    status CHAR(1) DEFAULT '1',
    create_time BIGINT,
    create_date DATETIME,
    update_time BIGINT,
    update_date DATETIME,
    INDEX idx_user_id (user_id),
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_role (role),
    INDEX idx_status (status)
);
```

**实际数据示例：**
```sql
-- 张三在研发部门是owner
INSERT INTO user_tenant VALUES (
    'ut_001', 
    'user_123', 
    'user_123', 
    'owner', 
    'user_123', 
    '1',
    1704067200,
    '2024-01-01 00:00:00',
    1704067200,
    '2024-01-01 00:00:00'
);

-- 李四在研发部门是admin
INSERT INTO user_tenant VALUES (
    'ut_002', 
    'user_456', 
    'user_123', 
    'admin', 
    'user_123', 
    '1',
    1704067200,
    '2024-01-01 00:00:00',
    1704067200,
    '2024-01-01 00:00:00'
);

-- 王五在研发部门是normal
INSERT INTO user_tenant VALUES (
    'ut_003', 
    'user_789', 
    'user_123', 
    'normal', 
    'user_456', 
    '1',
    1704067200,
    '2024-01-01 00:00:00',
    1704067200,
    '2024-01-01 00:00:00'
);

-- 赵六在研发部门是invite（未接受邀请）
INSERT INTO user_tenant VALUES (
    'ut_004', 
    'user_012', 
    'user_123', 
    'invite', 
    'user_456', 
    '1',
    1704067200,
    '2024-01-01 00:00:00',
    1704067200,
    '2024-01-01 00:00:00'
);
```

### 4. Knowledgebase 表（知识库表）

**表名：** `knowledgebase`  
**对应实体：** 知识库（数据集）

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | CharField(32) | 知识库唯一标识（主键） | "kb_001" |
| `avatar` | TextField | 知识库头像（base64编码） | "data:image/png;base64..." |
| `tenant_id` | CharField(32) | 所属租户ID | "user_123" |
| `name` | CharField(128) | 知识库名称 | "产品需求文档" |
| `language` | CharField(32) | 语言 | "Chinese" / "English" |
| `description` | TextField | 描述 | "包含所有产品需求文档" |
| `embd_id` | CharField(128) | 向量模型ID | "text-embedding-ada-002@openai" |
| `permission` | CharField(16) | **权限标记**（核心字段） | "me" / "team" |
| `created_by` | CharField(32) | 创建者用户ID | "user_123" |
| `doc_num` | IntegerField | 文档数量 | 10 |
| `token_num` | IntegerField | Token总数 | 50000 |
| `chunk_num` | IntegerField | 分块数量 | 200 |
| `similarity_threshold` | FloatField | 相似度阈值 | 0.2 |
| `vector_similarity_weight` | FloatField | 向量相似度权重 | 0.3 |
| `parser_id` | CharField(32) | 解析器ID | "naive" |
| `pipeline_id` | CharField(32) | 流水线ID | "pipeline_001" |
| `parser_config` | JSONField | 解析器配置 | `{"pages": [[1, 1000000]], ...}` |
| `pagerank` | IntegerField | PageRank值 | 0 |
| `graphrag_task_id` | CharField(32) | GraphRAG任务ID | "task_001" |
| `graphrag_task_finish_at` | DateTimeField | GraphRAG任务完成时间 | "2024-01-01 10:00:00" |
| `raptor_task_id` | CharField(32) | RAPTOR任务ID | "task_002" |
| `raptor_task_finish_at` | DateTimeField | RAPTOR任务完成时间 | "2024-01-01 10:00:00" |
| `mindmap_task_id` | CharField(32) | Mindmap任务ID | "task_003" |
| `mindmap_task_finish_at` | DateTimeField | Mindmap任务完成时间 | "2024-01-01 10:00:00" |
| `status` | CharField(1) | 知识库状态 | "1"（有效）/ "0"（无效） |
| `create_time` | BigIntegerField | 创建时间戳 | 1704067200 |
| `create_date` | DateTimeField | 创建日期 | "2024-01-01 00:00:00" |
| `update_time` | BigIntegerField | 更新时间戳 | 1704067200 |
| `update_date` | DateTimeField | 更新日期 | "2024-01-01 00:00:00" |

**关键字段说明：**
- `permission`：权限标记，决定知识库的访问范围
  - `me`：仅创建者可见
  - `team`：团队所有成员可见
- `created_by`：知识库创建者，只有创建者可以修改或删除知识库
- `tenant_id`：所属租户，用于权限隔离

**SQL示例：**
```sql
CREATE TABLE knowledgebase (
    id VARCHAR(32) PRIMARY KEY,
    avatar TEXT,
    tenant_id VARCHAR(32) NOT NULL,
    name VARCHAR(128) NOT NULL,
    language VARCHAR(32),
    description TEXT,
    embd_id VARCHAR(128) NOT NULL,
    permission VARCHAR(16) NOT NULL DEFAULT 'me',  -- me/team
    created_by VARCHAR(32) NOT NULL,
    doc_num INT DEFAULT 0,
    token_num INT DEFAULT 0,
    chunk_num INT DEFAULT 0,
    similarity_threshold FLOAT DEFAULT 0.2,
    vector_similarity_weight FLOAT DEFAULT 0.3,
    parser_id VARCHAR(32) NOT NULL,
    pipeline_id VARCHAR(32),
    parser_config TEXT,  -- JSON格式
    pagerank INT DEFAULT 0,
    graphrag_task_id VARCHAR(32),
    graphrag_task_finish_at DATETIME,
    raptor_task_id VARCHAR(32),
    raptor_task_finish_at DATETIME,
    mindmap_task_id VARCHAR(32),
    mindmap_task_finish_at DATETIME,
    status CHAR(1) DEFAULT '1',
    create_time BIGINT,
    create_date DATETIME,
    update_time BIGINT,
    update_date DATETIME,
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_permission (permission),
    INDEX idx_created_by (created_by),
    INDEX idx_status (status)
);
```

### 5. Document 表（文档表）

**表名：** `document`  
**对应实体：** 文档（知识库中的文档）

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | CharField(32) | 文档唯一标识（主键） | "doc_001" |
| `thumbnail` | TextField | 缩略图（base64编码） | "data:image/png;base64..." |
| `kb_id` | CharField(256) | 所属知识库ID | "kb_001" |
| `parser_id` | CharField(32) | 解析器ID | "naive" |
| `pipeline_id` | CharField(32) | 流水线ID | "pipeline_001" |
| `parser_config` | JSONField | 解析器配置 | `{"pages": [[1, 100]], ...}` |
| `source_type` | CharField(128) | 来源类型 | "local" / "web" / "api" |
| `type` | CharField(32) | 文件类型 | "pdf" / "docx" / "txt" |
| `created_by` | CharField(32) | 创建者用户ID | "user_123" |
| `name` | CharField(255) | 文件名 | "需求规格说明书.pdf" |
| `location` | CharField(255) | 存储位置 | "kb_001/file.pdf" |
| `size` | IntegerField | 文件大小（字节） | 1024000 |
| `token_num` | IntegerField | Token数量 | 5000 |
| `chunk_num` | IntegerField | 分块数量 | 20 |
| `progress` | FloatField | 处理进度 | 1.0（100%） |
| `progress_msg` | TextField | 处理消息 | "Parsing completed" |
| `process_begin_at` | DateTimeField | 处理开始时间 | "2024-01-01 10:00:00" |
| `process_duration` | FloatField | 处理耗时（秒） | 120.5 |
| `meta_fields` | JSONField | 元数据字段 | `{"author": "张三", ...}` |
| `suffix` | CharField(32) | 文件扩展名 | "pdf" |
| `run` | CharField(1) | 运行状态 | "0"（未运行）/ "1"（运行中）/ "2"（取消） |
| `status` | CharField(1) | 文档状态 | "1"（有效）/ "0"（无效） |
| `create_time` | BigIntegerField | 创建时间戳 | 1704067200 |
| `create_date` | DateTimeField | 创建日期 | "2024-01-01 00:00:00" |
| `update_time` | BigIntegerField | 更新时间戳 | 1704067200 |
| `update_date` | DateTimeField | 更新日期 | "2024-01-01 00:00:00" |

**关键字段说明：**
- `kb_id`：文档所属的知识库ID
- `created_by`：文档创建者
- `progress`：文档解析进度（0.0-1.0）
- `status`：文档状态，'0'=无效，'1'=有效

**SQL示例：**
```sql
CREATE TABLE document (
    id VARCHAR(32) PRIMARY KEY,
    thumbnail TEXT,
    kb_id VARCHAR(256) NOT NULL,
    parser_id VARCHAR(32) NOT NULL,
    pipeline_id VARCHAR(32),
    parser_config TEXT,  -- JSON格式
    source_type VARCHAR(128) NOT NULL DEFAULT 'local',
    type VARCHAR(32) NOT NULL,
    created_by VARCHAR(32) NOT NULL,
    name VARCHAR(255),
    location VARCHAR(255),
    size INT DEFAULT 0,
    token_num INT DEFAULT 0,
    chunk_num INT DEFAULT 0,
    progress FLOAT DEFAULT 0,
    progress_msg TEXT,
    process_begin_at DATETIME,
    process_duration FLOAT DEFAULT 0,
    meta_fields TEXT,  -- JSON格式
    suffix VARCHAR(32) NOT NULL,
    run CHAR(1) DEFAULT '0',
    status CHAR(1) DEFAULT '1',
    create_time BIGINT,
    create_date DATETIME,
    update_time BIGINT,
    update_date DATETIME,
    INDEX idx_kb_id (kb_id),
    INDEX idx_created_by (created_by),
    INDEX idx_status (status)
);
```

### 6. File 表（文件表）

**表名：** `file`  
**对应实体：** 文件（文件系统中的文件）

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `id` | CharField(32) | 文件唯一标识（主键） | "file_001" |
| `parent_id` | CharField(32) | 父文件夹ID | "folder_001" |
| `tenant_id` | CharField(32) | 所属租户ID | "user_123" |
| `created_by` | CharField(32) | 创建者用户ID | "user_123" |
| `name` | CharField(255) | 文件名或文件夹名 | "需求文档.pdf" |
| `location` | CharField(255) | 存储位置 | "kb_001/file.pdf" |
| `size` | IntegerField | 文件大小（字节） | 1024000 |
| `type` | CharField(32) | 文件类型 | "pdf" / "folder" |
| `source_type` | CharField(128) | 来源类型 | "local" / "knowledgebase" |
| `create_time` | BigIntegerField | 创建时间戳 | 1704067200 |
| `create_date` | DateTimeField | 创建日期 | "2024-01-01 00:00:00" |
| `update_time` | BigIntegerField | 更新时间戳 | 1704067200 |
| `update_date` | DateTimeField | 更新日期 | "2024-01-01 00:00:00" |

**关键字段说明：**
- `parent_id`：父文件夹ID，用于构建文件树结构
- `type`：文件类型，可以是文件扩展名或 "folder"
- `source_type`：来源类型，如 "knowledgebase" 表示来自知识库

**注意：** 文件的权限继承自所属知识库的权限。

**SQL示例：**
```sql
CREATE TABLE file (
    id VARCHAR(32) PRIMARY KEY,
    parent_id VARCHAR(32) NOT NULL,
    tenant_id VARCHAR(32) NOT NULL,
    created_by VARCHAR(32) NOT NULL,
    name VARCHAR(255) NOT NULL,
    location VARCHAR(255),
    size INT DEFAULT 0,
    type VARCHAR(32) NOT NULL,
    source_type VARCHAR(128) NOT NULL DEFAULT '',
    create_time BIGINT,
    create_date DATETIME,
    update_time BIGINT,
    update_date DATETIME,
    INDEX idx_parent_id (parent_id),
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_created_by (created_by)
);
```

### 7. 其他重要表

#### 7.1 File2Document 表（文件-文档关联表）

**表名：** `file2document`  
**作用：** 关联文件和文档，一个文件可以对应多个文档

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | CharField(32) | 关联唯一标识（主键） |
| `file_id` | CharField(32) | 文件ID |
| `document_id` | CharField(32) | 文档ID |

#### 7.2 Task 表（任务表）

**表名：** `task`  
**作用：** 存储文档解析任务信息

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | CharField(32) | 任务唯一标识（主键） |
| `doc_id` | CharField(32) | 文档ID |
| `from_page` | IntegerField | 起始页码 |
| `to_page` | IntegerField | 结束页码 |
| `task_type` | CharField(32) | 任务类型 |
| `priority` | IntegerField | 优先级 |
| `begin_at` | DateTimeField | 开始时间 |
| `process_duration` | FloatField | 处理耗时 |
| `progress` | FloatField | 进度 |
| `progress_msg` | TextField | 进度消息 |
| `retry_count` | IntegerField | 重试次数 |
| `digest` | TextField | 任务摘要 |
| `chunk_ids` | LongTextField | 分块ID列表 |

#### 7.3 Dialog 表（对话应用表）

**表名：** `dialog`  
**作用：** 存储对话应用（智能体）配置

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | CharField(32) | 对话应用唯一标识（主键） |
| `tenant_id` | CharField(32) | 所属租户ID |
| `name` | CharField(255) | 应用名称 |
| `description` | TextField | 描述 |
| `icon` | TextField | 图标（base64编码） |
| `language` | CharField(32) | 语言 |
| `llm_id` | CharField(128) | LLM模型ID |
| `llm_setting` | JSONField | LLM设置 |
| `prompt_type` | CharField(16) | 提示词类型 |
| `prompt_config` | JSONField | 提示词配置 |
| `meta_data_filter` | JSONField | 元数据过滤 |
| `similarity_threshold` | FloatField | 相似度阈值 |
| `vector_similarity_weight` | FloatField | 向量相似度权重 |
| `top_n` | IntegerField | Top N结果数 |
| `top_k` | IntegerField | Top K结果数 |
| `do_refer` | CharField(1) | 是否插入引用 |
| `rerank_id` | CharField(128) | 重排序模型ID |
| `kb_ids` | JSONField | 关联的知识库ID列表 |
| `status` | CharField(1) | 状态 |

#### 7.4 Conversation 表（会话表）

**表名：** `conversation`  
**作用：** 存储用户会话记录

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | CharField(32) | 会话唯一标识（主键） |
| `dialog_id` | CharField(32) | 对话应用ID |
| `name` | CharField(255) | 会话名称 |
| `message` | JSONField | 消息内容 |
| `reference` | JSONField | 引用信息 |
| `user_id` | CharField(255) | 用户ID |

#### 7.5 APIToken 表（API令牌表）

**表名：** `api_token`  
**作用：** 存储API访问令牌

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `tenant_id` | CharField(32) | 租户ID（复合主键） |
| `token` | CharField(255) | API令牌（复合主键） |
| `dialog_id` | CharField(32) | 关联的对话应用ID |
| `source` | CharField(16) | 来源类型 |
| `beta` | CharField(255) | Beta标识 |

**主键：** 复合主键 (`tenant_id`, `token`)

#### 7.6 TenantLLM 表（租户模型配置表）

**表名：** `tenant_llm`  
**作用：** 存储租户可用的模型配置（每个工作空间可以添加自己的模型）

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| `tenant_id` | CharField(32) | 租户ID（复合主键） | "user_123" |
| `llm_factory` | CharField(128) | 模型工厂（复合主键） | "OpenAI" / "Ollama" |
| `llm_name` | CharField(128) | 模型名称（复合主键） | "gpt-4" / "llama2" |
| `model_type` | CharField(128) | 模型类型 | "chat" / "embedding" / "image2text" |
| `api_key` | TextField | API密钥 | "sk-xxx..." |
| `api_base` | CharField(255) | API基础URL | "https://api.openai.com/v1" |
| `max_tokens` | IntegerField | 最大Token数 | 8192 |
| `used_tokens` | IntegerField | 已使用Token数 | 1000000 |
| `status` | CharField(1) | 状态 | "1"（启用）/ "0"（禁用） |
| `create_time` | BigIntegerField | 创建时间戳 | 1704067200 |
| `create_date` | DateTimeField | 创建日期 | "2024-01-01 00:00:00" |
| `update_time` | BigIntegerField | 更新时间戳 | 1704067200 |
| `update_date` | DateTimeField | 更新日期 | "2024-01-01 00:00:00" |

**主键：** 复合主键 (`tenant_id`, `llm_factory`, `llm_name`)

**关键字段说明：**
- `tenant_id`：所属租户，每个租户可以配置自己的模型
- `llm_factory`：模型工厂（提供商），如 OpenAI、Ollama、Azure-OpenAI 等
- `llm_name`：具体的模型名称，如 "gpt-4"、"gpt-3.5-turbo" 等
- `api_key`：API密钥，用于访问模型服务
- `api_base`：API基础URL，用于自定义API端点
- `model_type`：模型类型，决定模型的用途
  - `chat`：聊天模型
  - `embedding`：向量模型
  - `image2text`：图像转文本模型
  - `speech2text`：语音转文本模型
  - `rerank`：重排序模型
  - `tts`：文本转语音模型

**前端体现：**

TenantLLM 表在前端的体现主要在**模型配置页面**（`/user-setting/model`）：

**重要说明：**

**为什么看起来像是用户级别的配置？**
- `/user-setting/model` 页面配置的是**当前用户作为OWNER的租户**的模型，而不是用户级别的配置
- 每个用户注册时会自动创建一个租户，租户ID = 用户ID，用户在该租户中的角色是 `OWNER`
- 因为每个用户默认拥有一个租户（租户ID = 用户ID），所以看起来像是用户级别的配置
- 但实际上，这是**租户级别的配置**，存储在 `tenant_llm` 表中，以 `tenant_id` 为标识

**实际关系：**
```
用户注册
  ↓
自动创建租户（tenant_id = user_id）
  ↓
用户在该租户中的角色 = OWNER
  ↓
模型配置页面显示的是该租户的模型配置
```

**限制：**
- 如果用户加入了其他租户（作为 `NORMAL` 或 `ADMIN`），他们无法在 `/user-setting/model` 页面配置那些租户的模型
- 只能配置自己作为 `OWNER` 的租户的模型
- 这是因为后端API使用 `current_user.id` 作为 `tenant_id`，而 `tenant_info` API只返回用户作为 `OWNER` 的租户信息

**后端实现逻辑：**
```python
# api/apps/llm_app.py
# 所有模型配置操作都使用 current_user.id 作为 tenant_id
tenant_id = current_user.id  # 实际上是用户作为OWNER的租户ID

# api/apps/user_app.py - tenant_info API
# 获取当前用户作为OWNER的租户信息
tenants = TenantService.get_info_by(current_user.id)  # 查找用户作为OWNER的租户
```

**1. 已添加的模型列表（UsedModel组件）**
- **位置：** 模型配置页面左侧
- **数据来源：** `GET /api/v1/llm/my_llms` API
- **显示内容：** 显示当前用户作为OWNER的租户已添加的所有模型（TenantLLM表中的记录）
- **操作：** 可以编辑、删除已添加的模型

**2. 可用的模型列表（AvailableModels组件）**
- **位置：** 模型配置页面右侧
- **数据来源：** `GET /api/v1/llm/list` API
- **显示内容：** 显示系统支持的所有模型（LLM表中的记录）
- **操作：** 点击"添加模型"按钮，可以添加模型到当前用户作为OWNER的租户

**3. 添加模型流程**
- 用户点击"添加模型"按钮
- 根据模型工厂类型，弹出不同的配置对话框：
  - **Ollama/LocalAI等本地模型：** 需要填写 `api_base`、`llm_name`、`model_type`、`max_tokens`
  - **OpenAI等云服务：** 需要填写 `api_key`、`api_base`、`llm_name`、`model_type`
  - **其他特殊模型：** 根据模型工厂的不同，需要不同的配置项
- 提交后调用 `POST /api/v1/llm/add_llm` API
- 后端使用 `current_user.id` 作为 `tenant_id`，验证API密钥有效性后，创建TenantLLM记录

**4. 设置API Key流程**
- 对于某些模型工厂（如OpenAI），只需要设置API Key
- 用户点击"设置API Key"按钮
- 填写API Key和Base URL
- 提交后调用 `POST /api/v1/llm/set_api_key` API
- 后端使用 `current_user.id` 作为 `tenant_id`，验证API Key有效性后，更新或创建TenantLLM记录

**5. 系统模型设置（SystemSetting组件）**
- **位置：** 模型配置页面顶部
- **功能：** 设置当前用户作为OWNER的租户的默认模型（对应tenant表的字段）
- **可设置项：**
  - 聊天模型（`llm_id`）
  - 向量模型（`embd_id`）
  - 图像转文本模型（`img2txt_id`）
  - 语音转文本模型（`asr_id`）
  - 重排序模型（`rerank_id`）
  - 文本转语音模型（`tts_id`）
- **注意：** 这里设置的是默认模型，必须从已添加的模型（TenantLLM表）中选择

**实际例子：**

```python
# TenantLLM表中的记录示例
tenant_llm_1 = {
    "tenant_id": "user_123",
    "llm_factory": "OpenAI",
    "llm_name": "gpt-4",
    "model_type": "chat",
    "api_key": "sk-xxx...",
    "api_base": "https://api.openai.com/v1",
    "max_tokens": 8192,
    "used_tokens": 1000000,
    "status": "1"
}

tenant_llm_2 = {
    "tenant_id": "user_123",
    "llm_factory": "OpenAI",
    "llm_name": "text-embedding-ada-002",
    "model_type": "embedding",
    "api_key": "sk-xxx...",
    "api_base": "https://api.openai.com/v1",
    "max_tokens": 8192,
    "used_tokens": 500000,
    "status": "1"
}

tenant_llm_3 = {
    "tenant_id": "user_123",
    "llm_factory": "Ollama",
    "llm_name": "llama2",
    "model_type": "chat",
    "api_key": None,  # 本地模型不需要API Key
    "api_base": "http://localhost:11434",
    "max_tokens": 4096,
    "used_tokens": 0,
    "status": "1"
}
```

**前端操作流程：**

1. **添加OpenAI模型：**
   - 进入模型配置页面
   - 在右侧"可用模型"列表中找到"OpenAI"
   - 点击"添加模型"按钮
   - 填写API Key和Base URL
   - 选择模型类型和模型名称
   - 提交后，系统验证API Key有效性
   - 验证通过后，创建TenantLLM记录

2. **添加Ollama本地模型：**
   - 进入模型配置页面
   - 在右侧"可用模型"列表中找到"Ollama"
   - 点击"添加模型"按钮
   - 填写Base URL（如：http://localhost:11434）
   - 填写模型名称（如：llama2）
   - 选择模型类型
   - 提交后，创建TenantLLM记录

3. **设置默认模型：**
   - 在模型配置页面顶部"系统模型设置"区域
   - 从下拉列表中选择已添加的模型
   - 系统自动保存到tenant表的对应字段

**后端API接口：**

| API路径 | 方法 | 功能 | 对应操作 |
|---------|------|------|---------|
| `/llm/my_llms` | GET | 获取当前租户的模型列表 | 显示"已添加的模型" |
| `/llm/list` | GET | 获取所有可用模型列表 | 显示"可用的模型" |
| `/llm/add_llm` | POST | 添加模型到租户 | 创建TenantLLM记录 |
| `/llm/set_api_key` | POST | 设置API Key | 更新/创建TenantLLM记录 |
| `/llm/delete_llm` | POST | 删除模型 | 删除TenantLLM记录 |
| `/llm/update_llm` | POST | 更新模型配置 | 更新TenantLLM记录 |
| `/llm/update_llm_status` | POST | 更新模型状态 | 更新TenantLLM的status字段 |

**SQL示例：**
```sql
CREATE TABLE tenant_llm (
    tenant_id VARCHAR(32) NOT NULL,
    llm_factory VARCHAR(128) NOT NULL,
    llm_name VARCHAR(128) NOT NULL,
    model_type VARCHAR(128),
    api_key TEXT,
    api_base VARCHAR(255),
    max_tokens INT DEFAULT 8192,
    used_tokens INT DEFAULT 0,
    status CHAR(1) DEFAULT '1',
    create_time BIGINT,
    create_date DATETIME,
    update_time BIGINT,
    update_date DATETIME,
    PRIMARY KEY (tenant_id, llm_factory, llm_name),
    INDEX idx_tenant_id (tenant_id),
    INDEX idx_llm_factory (llm_factory),
    INDEX idx_model_type (model_type),
    INDEX idx_status (status)
);
```

#### 7.7 UserCanvas 表（用户画布表）

**表名：** `user_canvas`  
**作用：** 存储用户创建的画布（智能体工作流）

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | CharField(32) | 画布唯一标识（主键） |
| `avatar` | TextField | 头像 |
| `user_id` | CharField(255) | 用户ID |
| `title` | CharField(255) | 标题 |
| `permission` | CharField(16) | 权限（me/team） |
| `description` | TextField | 描述 |
| `canvas_type` | CharField(32) | 画布类型 |
| `canvas_category` | CharField(32) | 画布分类 |
| `dsl` | JSONField | DSL配置 |

#### 7.8 Search 表（搜索应用表）

**表名：** `search`  
**作用：** 存储搜索应用配置

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | CharField(32) | 搜索应用唯一标识（主键） |
| `avatar` | TextField | 头像 |
| `tenant_id` | CharField(32) | 所属租户ID |
| `name` | CharField(128) | 名称 |
| `description` | TextField | 描述 |
| `created_by` | CharField(32) | 创建者用户ID |
| `search_config` | JSONField | 搜索配置 |
| `status` | CharField(1) | 状态 |

#### 7.9 Connector 表（连接器表）

**表名：** `connector`  
**作用：** 存储数据源连接器配置

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `id` | CharField(32) | 连接器唯一标识（主键） |
| `tenant_id` | CharField(32) | 所属租户ID |
| `name` | CharField(128) | 名称 |
| `source` | CharField(128) | 数据源类型 |
| `input_type` | CharField(128) | 输入类型 |
| `config` | JSONField | 配置信息 |
| `refresh_freq` | IntegerField | 刷新频率 |
| `prune_freq` | IntegerField | 清理频率 |
| `timeout_secs` | IntegerField | 超时时间（秒） |
| `indexing_start` | DateTimeField | 索引开始时间 |
| `status` | CharField(16) | 状态 |

### 表关系图

```
┌─────────┐
│  User   │ (用户表)
└────┬────┘
     │
     │ 多对多关系
     │
┌────▼──────────────┐
│   UserTenant      │ (用户-租户关系表)
│  - user_id        │
│  - tenant_id      │
│  - role           │ ← 核心权限字段
└────┬──────────────┘
     │
     │ 关联到
     │
┌────▼─────────┐
│   Tenant     │ (租户表)
└────┬─────────┘
     │
     │ 拥有
     │
┌────▼──────────────┐      ┌──────────────┐
│  Knowledgebase    │      │   Document   │ (文档表)
│  - tenant_id      │◄─────┤  - kb_id     │
│  - permission     │      │  - created_by│
│  - created_by     │      └──────────────┘
└────┬──────────────┘
     │
     │ 包含
     │
┌────▼─────┐      ┌──────────────┐
│   File   │      │ File2Document│ (文件-文档关联表)
│  - tenant_id │◄─┤  - file_id   │
│  - parent_id│   │  - document_id│
└──────────┘      └──────────────┘
```

### 通用字段说明

所有继承自 `DataBaseModel` 的表都包含以下通用字段：

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `create_time` | BigIntegerField | 创建时间戳（Unix时间戳） |
| `create_date` | DateTimeField | 创建日期（可读格式） |
| `update_time` | BigIntegerField | 更新时间戳（Unix时间戳） |
| `update_date` | DateTimeField | 更新日期（可读格式） |

这些字段由系统自动管理，无需手动设置。

---

## 权限检查机制

### 1. 认证装饰器

系统提供了多个装饰器用于权限验证：

#### 1.1 `login_required` 装饰器

**位置：** `api/apps/__init__.py`

**功能：** 验证Web界面的用户登录状态

**使用示例：**
```python
from api.apps import login_required, current_user

@manager.route("/datasets", methods=["GET"])
@login_required
async def list_datasets():
    # 只有登录用户才能访问
    user_id = current_user.id
    # ... 业务逻辑
```

**实际例子：**
```python
# 用户未登录时访问 /datasets
# 结果：返回 401 Unauthorized 错误

# 用户已登录时访问 /datasets
# 结果：正常返回数据列表
```

#### 1.2 `token_required` 装饰器

**位置：** `api/utils/api_utils.py`

**功能：** 验证API Token，提取tenant_id

**工作流程：**
1. 检查是否设置了 `DISABLE_SDK` 环境变量
2. 从请求头中获取 `Authorization` 字段
3. 验证Authorization格式（应为 "Bearer <token>" 或类似格式）
4. 提取token并查询数据库中的 `APIToken` 表
5. 如果token有效，将 `tenant_id` 添加到kwargs中

**使用示例：**
```python
from api.utils.api_utils import token_required

@manager.route("/datasets", methods=["GET"])
@token_required
def list_datasets(tenant_id):  # tenant_id由装饰器自动注入
    # tenant_id 已经通过token验证并提取
    # ... 业务逻辑
```

**实际例子：**
```python
# 请求头
headers = {
    "Authorization": "Bearer api_token_12345"
}

# 装饰器验证流程：
# 1. 提取token: "api_token_12345"
# 2. 查询APIToken表，找到对应的tenant_id: "dev_team_001"
# 3. 将tenant_id注入到函数参数中
# 4. 执行函数: list_datasets(tenant_id="dev_team_001")
```

#### 1.3 `apikey_required` 装饰器

**位置：** `api/utils/api_utils.py`

**功能：** 简化版的API密钥验证（仅异步函数）

**使用示例：**
```python
from api.utils.api_utils import apikey_required

@manager.route("/datasets", methods=["GET"])
@apikey_required
async def list_datasets(tenant_id):
    # tenant_id由装饰器自动注入
    # ... 业务逻辑
```

#### 1.4 `active_required` 装饰器

**位置：** `api/utils/api_utils.py`

**功能：** 验证用户是否处于活跃状态

**使用示例：**
```python
from api.utils.api_utils import active_required

@manager.route("/datasets", methods=["POST"])
@login_required
@active_required
async def create_dataset():
    # 只有活跃用户才能创建数据集
    # ... 业务逻辑
```

**实际例子：**
```python
# 用户状态为不活跃（is_active="0"）
# 访问创建数据集接口
# 结果：返回错误 "User isn't active, please activate first."

# 用户状态为活跃（is_active="1"）
# 访问创建数据集接口
# 结果：正常创建数据集
```

### 2. 权限检查流程

完整的权限检查流程如下：

```
┌─────────────────┐
│   API请求到达    │
└────────┬─────────┘
         │
         ▼
┌─────────────────┐
│  装饰器拦截      │
│  (login_required│
│   /token_required)│
└────────┬─────────┘
         │
         ▼
┌─────────────────┐
│  Token验证      │
│  - 检查Authorization头│
│  - 验证token格式│
│  - 查询APIToken表│
└────────┬─────────┘
         │
         ▼
┌─────────────────┐
│  权限提取       │
│  - 提取tenant_id│
│  - 获取user_id  │
└────────┬─────────┘
         │
         ▼
┌─────────────────┐
│  业务逻辑处理   │
│  - 检查资源权限 │
│  - 执行操作     │
└────────┬─────────┘
         │
         ▼
┌─────────────────┐
│  返回结果       │
└─────────────────┘
```

### 3. 错误处理

系统定义了标准的错误码和错误信息：

| 错误场景 | 错误信息 | 错误码 |
|---------|---------|-------|
| Authorization头为空 | `Authorization` can't be empty | 0 |
| Authorization格式错误 | Please check your authorization format. | 0 |
| token无效 | Authentication error: API key is invalid! | RetCode.AUTHENTICATION_ERROR |
| API-KEY无效 | API-KEY is invalid! | RetCode.FORBIDDEN |
| 用户不活跃 | User isn't active, please activate first. | RetCode.FORBIDDEN |
| 权限不足 | Permission error | RetCode.PERMISSION_ERROR |

---

## 实际应用场景

### 场景1：新员工入职流程

**背景：** 公司新招聘了一名研发工程师王五，需要加入研发部门。

**步骤：**

1. **创建用户账号**
```python
# 管理员操作
user = UserService.create_user(
    email="wangwu@example.com",
    password="hashed_password",
    nickname="王五"
)
```

2. **发送邀请**
```python
# 研发经理李四（admin）发送邀请
UserTenantService.save(
    user_id="wangwu@example.com",
    tenant_id="dev_team_001",
    role="invite",  # 初始状态为invite
    invited_by="lisi@example.com"
)
```

3. **王五接受邀请**
```python
# 王五登录系统，接受邀请
UserTenantService.update(
    user_tenant_id="ut_003",
    role="normal"  # 从invite变为normal
)
```

4. **权限生效**
```python
# 王五现在可以访问团队共享的知识库
kb = {
    "id": "kb_001",
    "tenant_id": "dev_team_001",
    "permission": "team"
}

# 检查权限
check_kb_team_permission(kb, "wangwu@example.com")
# 结果：True ✅
```

### 场景2：知识库权限管理

**背景：** 张三创建了一个知识库，需要控制访问权限。

**步骤：**

1. **创建私有知识库**
```python
# 张三创建个人笔记
kb = KnowledgebaseService.create(
    name="张三的个人笔记",
    tenant_id="dev_team_001",
    permission="me"  # 仅自己可见
)
```

**效果：**
- ✅ 张三可以访问
- ✅ 超级用户可以访问
- ❌ 李四（admin）无法访问
- ❌ 王五（normal）无法访问

2. **改为团队共享**
```python
# 张三将知识库改为团队共享
KnowledgebaseService.update(
    kb_id="kb_001",
    permission="team"  # 改为团队共享
)
```

**效果：**
- ✅ 张三可以访问
- ✅ 李四（admin）可以访问
- ✅ 王五（normal）可以访问
- ❌ 赵六（invite）无法访问（尚未接受邀请）

### 场景3：跨租户访问（超级用户）

**背景：** 系统管理员需要查看所有部门的知识库。

**步骤：**

1. **设置超级用户**
```python
# 设置admin@ragflow.io为超级用户
UserService.update(
    user_id="admin@ragflow.io",
    is_superuser=True
)
```

2. **访问任意租户资源**
```python
# 超级用户访问研发部门的知识库
kb = {
    "id": "kb_001",
    "tenant_id": "dev_team_001",
    "permission": "me"  # 即使是私有知识库
}

# 权限检查（伪代码）
if user.is_superuser:
    return True  # 超级用户可以直接访问

# 结果：✅ 有权限（绕过所有权限检查）
```

### 场景4：API Token访问

**背景：** 开发者需要通过API程序化访问系统。

**步骤：**

1. **创建API Token**
```python
# 为研发部门创建API Token
api_token = APITokenService.create(
    tenant_id="dev_team_001",
    token="api_token_12345"
)
```

2. **使用Token访问API**
```python
# 请求头
headers = {
    "Authorization": "Bearer api_token_12345"
}

# 调用API
response = requests.get(
    "https://api.example.com/v1/datasets",
    headers=headers
)

# 装饰器自动验证token并提取tenant_id
# 返回dev_team_001租户下的所有知识库
```

### 场景5：角色权限差异

**背景：** 不同角色在同一租户中的权限差异。

**知识库：产品需求文档（team共享）**

| 用户 | 角色 | 权限 | 说明 |
|------|------|------|------|
| 张三 | owner | ✅ 查看、编辑、删除、分享、管理成员 | 租户创建者，拥有所有权限 |
| 李四 | admin | ✅ 查看、编辑、删除、分享 | 管理员，可管理资源 |
| 王五 | normal | ✅ 查看、编辑 | 普通成员，可访问团队资源 |
| 赵六 | invite | ❌ 无权限 | 尚未接受邀请 |

**实际代码检查：**
```python
# 李四（admin）访问知识库
kb = {"id": "kb_001", "tenant_id": "dev_team_001", "permission": "team"}
user_id = "lisi@example.com"

# 检查流程
user_tenant = UserTenantService.query(
    user_id="lisi@example.com",
    tenant_id="dev_team_001"
)
# user_tenant.role = "admin"

# 权限检查
if kb["permission"] == "team":
    if user_tenant.role != "invite":
        return True  # ✅ 有权限

# 结果：李四可以访问知识库
```

---

## API接口说明

### 1. 管理API（Admin API）

**基础路径：** `/api/v1/admin`

#### 1.1 用户管理

| 接口 | 方法 | 功能 | 权限要求 |
|------|------|------|----------|
| `/users` | GET | 获取所有用户列表 | 管理员 |
| `/users` | POST | 创建用户 | 管理员 |
| `/users/<username>` | GET | 获取用户详情 | 管理员 |
| `/users/<username>` | DELETE | 删除用户 | 管理员 |
| `/users/<username>/password` | PUT | 修改用户密码 | 管理员 |
| `/users/<username>/activate` | PUT | 激活/禁用用户 | 管理员 |
| `/users/<username>/datasets` | GET | 获取用户的知识库 | 管理员 |
| `/users/<username>/agents` | GET | 获取用户的智能体 | 管理员 |

**实际例子：**
```bash
# 获取所有用户列表
curl -X GET "http://localhost:9380/api/v1/admin/users" \
  -H "Authorization: Bearer admin_token"

# 创建新用户
curl -X POST "http://localhost:9380/api/v1/admin/users" \
  -H "Authorization: Bearer admin_token" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "wangwu@example.com",
    "password": "password123",
    "role": "user"
  }'
```

#### 1.2 角色管理

| 接口 | 方法 | 功能 | 权限要求 |
|------|------|------|----------|
| `/roles` | GET | 获取角色列表 | 管理员 |
| `/roles` | POST | 创建角色 | 管理员 |
| `/roles/<role_name>` | PUT | 更新角色描述 | 管理员 |
| `/roles/<role_name>` | DELETE | 删除角色 | 管理员 |
| `/roles/<role_name>/permission` | GET | 获取角色权限 | 管理员 |
| `/roles/<role_name>/permission` | POST | 分配角色权限 | 管理员 |
| `/roles/<role_name>/permission` | DELETE | 撤销角色权限 | 管理员 |
| `/users/<user_name>/role` | PUT | 更新用户角色 | 管理员 |
| `/users/<user_name>/permission` | GET | 获取用户权限 | 管理员 |

**注意：** 当前实现中，RoleMgr 的方法都返回 "not implement" 错误，这些功能可能尚未完全实现。

**实际例子：**
```bash
# 获取角色列表
curl -X GET "http://localhost:9380/api/v1/admin/roles" \
  -H "Authorization: Bearer admin_token"

# 获取角色权限
curl -X GET "http://localhost:9380/api/v1/admin/roles/admin/permission" \
  -H "Authorization: Bearer admin_token"
```

### 2. 业务API（Business API）

**基础路径：** `/api/v1`

#### 2.1 知识库管理

| 接口 | 方法 | 功能 | 权限要求 |
|------|------|------|----------|
| `/datasets` | GET | 获取知识库列表 | 登录用户 |
| `/datasets` | POST | 创建知识库 | 登录用户 |
| `/datasets/<dataset_id>` | GET | 获取知识库详情 | 有权限的用户 |
| `/datasets/<dataset_id>` | PUT | 更新知识库 | 所有者/管理员 |
| `/datasets/<dataset_id>` | DELETE | 删除知识库 | 所有者/管理员 |

**实际例子：**
```bash
# 获取知识库列表（Web界面）
curl -X GET "http://localhost:9380/api/v1/datasets" \
  -H "Cookie: session=user_session_token"

# 获取知识库列表（API Token）
curl -X GET "http://localhost:9380/api/v1/datasets" \
  -H "Authorization: Bearer api_token_12345"
```

#### 2.2 文档管理

| 接口 | 方法 | 功能 | 权限要求 |
|------|------|------|----------|
| `/document/list` | POST | 获取文档列表 | 有权限的用户 |
| `/document/create` | POST | 创建文档 | 有权限的用户 |
| `/document/<document_id>` | GET | 获取文档详情 | 有权限的用户 |
| `/document/<document_id>` | DELETE | 删除文档 | 所有者/管理员 |

**权限检查逻辑：**
```python
# 在api/apps/document_app.py中
@manager.route("/list", methods=["POST"])
@login_required
async def list_docs():
    kb_id = request.args.get("kb_id")
    
    # 检查用户是否有权限访问该知识库
    tenants = UserTenantService.query(user_id=current_user.id)
    for tenant in tenants:
        if KnowledgebaseService.query(tenant_id=tenant.tenant_id, id=kb_id):
            break
    else:
        return get_json_result(
            data=False,
            message="Only owner of knowledgebase authorized for this operation.",
            code=RetCode.OPERATING_ERROR
        )
    
    # ... 返回文档列表
```

---

## 代码实现细节

### 1. 权限检查函数实现

#### 1.1 知识库权限检查

**文件：** `api/common/check_team_permission.py`

```python
def check_kb_team_permission(kb: dict | Knowledgebase, other: str) -> bool:
    """
    检查用户是否有权限访问知识库
    
    参数:
        kb: 知识库对象或字典，必须包含tenant_id和permission字段
        other: 用户ID
    
    返回:
        bool: True表示有权限，False表示无权限
    
    逻辑:
        1. 如果用户是知识库所属租户的创建者（owner），直接返回True
        2. 如果知识库权限为team，检查用户是否是该租户的成员
        3. 如果知识库权限为me，且用户不是创建者，返回False
    """
    kb = kb.to_dict() if isinstance(kb, Knowledgebase) else kb
    
    kb_tenant_id = kb["tenant_id"]
    
    # 情况1：用户是租户创建者
    if kb_tenant_id == other:
        return True
    
    # 情况2：知识库权限为team，需要检查用户是否是租户成员
    if kb["permission"] != TenantPermission.TEAM:
        return False
    
    # 获取用户加入的所有租户
    joined_tenants = TenantService.get_joined_tenants_by_user_id(other)
    return any(tenant["tenant_id"] == kb_tenant_id for tenant in joined_tenants)
```

**调用示例：**
```python
# 在知识库列表API中
@manager.route("/datasets", methods=["GET"])
@login_required
async def list_datasets():
    user_id = current_user.id
    
    # 获取用户加入的所有租户
    tenants = TenantService.get_joined_tenants_by_user_id(user_id)
    tenant_ids = [t["tenant_id"] for t in tenants]
    
    # 获取知识库列表（自动过滤权限）
    kbs, total = KnowledgebaseService.get_by_tenant_ids(
        joined_tenant_ids=tenant_ids,
        user_id=user_id,
        page_number=1,
        items_per_page=10,
        orderby="create_time",
        desc=True,
        keywords=None
    )
    
    # 返回结果
    return get_result(data=kbs, total=total)
```

#### 1.2 文件权限检查

**文件：** `api/common/check_team_permission.py`

```python
def check_file_team_permission(file: dict | File, other: str) -> bool:
    """
    检查用户是否有权限访问文件
    
    文件权限继承自所属知识库的权限
    
    参数:
        file: 文件对象或字典，必须包含id和tenant_id字段
        other: 用户ID
    
    返回:
        bool: True表示有权限，False表示无权限
    
    逻辑:
        1. 如果用户是文件所属租户的创建者，直接返回True
        2. 获取文件所属的所有知识库
        3. 检查文件所属的任一知识库是否有权限
    """
    file = file.to_dict() if isinstance(file, File) else file
    
    file_tenant_id = file["tenant_id"]
    if file_tenant_id == other:
        return True
    
    file_id = file["id"]
    
    # 获取文件所属的所有知识库
    kb_ids = [kb_info["kb_id"] for kb_info in FileService.get_kb_id_by_file_id(file_id)]
    
    # 检查文件所属的任一知识库是否有权限
    for kb_id in kb_ids:
        ok, kb = KnowledgebaseService.get_by_id(kb_id)
        if not ok:
            continue
        
        if check_kb_team_permission(kb, other):
            return True
    
    return False
```

### 2. 知识库查询实现

**文件：** `api/db/services/knowledgebase_service.py`

```python
@classmethod
@DB.connection_context()
def get_by_tenant_ids(cls, joined_tenant_ids, user_id,
                      page_number, items_per_page,
                      orderby, desc, keywords,
                      parser_id=None):
    """
    根据租户ID列表获取知识库列表（带权限过滤）
    
    权限逻辑:
        - 用户自己创建的知识库（tenant_id == user_id）始终可见
        - 权限为team的知识库，如果用户是该租户的成员，则可见
        - 权限为me的知识库，只有创建者可见
    """
    fields = [
        cls.model.id,
        cls.model.name,
        cls.model.tenant_id,
        cls.model.permission,
        # ... 其他字段
    ]
    
    # 权限过滤条件
    # 条件1：用户自己创建的知识库
    # 条件2：权限为team且用户是租户成员的知识库
    permission_condition = (
        (cls.model.tenant_id.in_(joined_tenant_ids) & 
         (cls.model.permission == TenantPermission.TEAM.value)) |
        (cls.model.tenant_id == user_id)
    )
    
    if keywords:
        kbs = cls.model.select(*fields).join(
            User, on=(cls.model.tenant_id == User.id)
        ).where(
            permission_condition &
            (cls.model.status == StatusEnum.VALID.value) &
            (fn.LOWER(cls.model.name).contains(keywords.lower()))
        )
    else:
        kbs = cls.model.select(*fields).join(
            User, on=(cls.model.tenant_id == User.id)
        ).where(
            permission_condition &
            (cls.model.status == StatusEnum.VALID.value)
        )
    
    if parser_id:
        kbs = kbs.where(cls.model.parser_id == parser_id)
    
    if desc:
        kbs = kbs.order_by(cls.model.getter_by(orderby).desc())
    else:
        kbs = kbs.order_by(cls.model.getter_by(orderby).asc())
    
    count = kbs.count()
    
    if page_number and items_per_page:
        kbs = kbs.paginate(page_number, items_per_page)
    
    return list(kbs.dicts()), count
```

### 3. 租户服务实现

**文件：** `api/db/services/user_service.py`

```python
class TenantService(CommonService):
    model = Tenant
    
    @classmethod
    @DB.connection_context()
    def get_joined_tenants_by_user_id(cls, user_id):
        """
        获取用户加入的所有租户（不包括owner角色）
        
        返回:
            List[Dict]: 租户信息列表，包含tenant_id、name、role等字段
        """
        fields = [
            cls.model.id.alias("tenant_id"),
            cls.model.name,
            cls.model.llm_id,
            cls.model.embd_id,
            UserTenant.role
        ]
        
        return list(
            cls.model.select(*fields)
            .join(
                UserTenant,
                on=(
                    (cls.model.id == UserTenant.tenant_id) &
                    (UserTenant.user_id == user_id) &
                    (UserTenant.status == StatusEnum.VALID.value) &
                    (UserTenant.role == UserTenantRole.NORMAL)  # 只查询normal角色
                )
            )
            .where(cls.model.status == StatusEnum.VALID.value)
            .dicts()
        )
```

---

## 租户创建与管理

### 用户注册时的租户自动创建

**重要：** 用户注册成功后，系统会自动为其创建一个租户（工作空间）。

#### 自动创建流程

当用户注册时，系统会执行以下操作：

1. **创建用户账号**（User表）
2. **自动创建租户**（Tenant表）
   - 租户ID = 用户ID（`tenant.id = user.id`）
   - 租户名称 = `"{nickname}'s Kingdom"`（例如："张三's Kingdom"）
   - 使用系统默认的模型配置
3. **创建用户-租户关系**（UserTenant表）
   - 用户角色：`owner`（创建者）
   - 关系状态：`valid`
4. **创建根文件夹**（File表）
   - 创建租户的根目录文件夹
5. **初始化租户模型配置**（TenantLLM表）
   - 初始化租户可用的模型列表

**代码实现：**
```python
# api/apps/user_app.py
def user_register(user_id, user):
    # 1. 创建租户
    tenant = {
        "id": user_id,  # 租户ID = 用户ID
        "name": user["nickname"] + "'s Kingdom",  # 租户名称
        "llm_id": settings.CHAT_MDL,  # 默认LLM模型
        "embd_id": settings.EMBEDDING_MDL,  # 默认向量模型
        "asr_id": settings.ASR_MDL,  # 默认ASR模型
        "parser_ids": settings.PARSERS,  # 默认解析器
        "img2txt_id": settings.IMAGE2TEXT_MDL,  # 默认图像转文本模型
        "rerank_id": settings.RERANK_MDL,  # 默认重排序模型
    }
    
    # 2. 创建用户-租户关系
    usr_tenant = {
        "tenant_id": user_id,
        "user_id": user_id,
        "invited_by": user_id,
        "role": UserTenantRole.OWNER,  # 角色为owner
    }
    
    # 3. 创建根文件夹
    file = {
        "id": file_id,
        "parent_id": file_id,
        "tenant_id": user_id,
        "created_by": user_id,
        "name": "/",
        "type": FileType.FOLDER.value,
    }
    
    # 4. 执行创建操作
    UserService.save(**user)
    TenantService.insert(**tenant)
    UserTenantService.insert(**usr_tenant)
    TenantLLMService.insert_many(tenant_llm)
    FileService.insert(file)
```

**实际例子：**
```python
# 用户注册
user = {
    "email": "zhangsan@example.com",
    "nickname": "张三",
    "password": "hashed_password"
}

# 注册后自动创建：
tenant = {
    "id": "user_id_123",  # 等于用户ID
    "name": "张三's Kingdom",  # 租户名称
    "llm_id": "gpt-4@openai",
    "embd_id": "text-embedding-ada-002@openai",
    # ... 其他默认配置
}

user_tenant = {
    "user_id": "user_id_123",
    "tenant_id": "user_id_123",
    "role": "owner"  # 用户是租户的创建者
}
```

### 租户管理功能

#### 后端API功能

**1. 获取租户信息**
- **API路径：** `/api/v1/user/tenant_info`
- **方法：** `GET`
- **功能：** 获取当前用户的工作空间（租户）信息
- **返回数据：**
  ```json
  {
    "tenant_id": "user_id",
    "name": "张三's Kingdom",
    "llm_id": "gpt-4@openai",
    "embd_id": "text-embedding-ada-002@openai",
    "asr_id": "...",
    "img2txt_id": "...",
    "rerank_id": "...",
    "parser_ids": "...",
    "role": "owner"
  }
  ```

**2. 更新租户配置**
- **API路径：** `/api/v1/user/set_tenant_info`
- **方法：** `POST`
- **功能：** 更新租户的模型配置
- **可更新字段：**
  - `llm_id`：LLM模型ID
  - `embd_id`：向量模型ID
  - `asr_id`：ASR模型ID
  - `img2txt_id`：图像转文本模型ID
  - `rerank_id`：重排序模型ID
- **注意：** **不能更新租户名称（name字段）**

**代码实现：**
```python
# api/apps/user_app.py
@manager.route("/set_tenant_info", methods=["POST"])
@login_required
@validate_request("tenant_id", "asr_id", "embd_id", "img2txt_id", "llm_id")
async def set_tenant_info():
    req = await get_request_json()
    tid = req.pop("tenant_id")
    TenantService.update_by_id(tid, req)  # 只能更新模型配置
    return get_json_result(data=True)
```

#### 前端功能

**1. 模型配置页面**
- **路径：** `/user-setting/model`
- **功能：** 编辑工作空间的模型配置
- **可配置项：**
  - 聊天模型（LLM）
  - 向量模型（Embedding）
  - ASR模型
  - 图像转文本模型
  - 重排序模型
  - 解析器配置

**2. 团队管理页面**
- **路径：** `/user-setting/team`
- **功能：** 管理团队成员和查看已加入的团队
- **不包含：** 租户名称编辑功能

#### 租户名称管理

**当前限制：**
- ❌ **前端没有租户名称编辑页面**
- ❌ **后端API不支持更新租户名称**
- ✅ 租户名称在注册时自动设置为 `"{nickname}'s Kingdom"`
- ✅ 租户名称可以通过数据库直接修改（不推荐）

**为什么没有租户名称编辑功能？**
1. **设计理念：** 租户名称主要用于标识，不是核心功能
2. **简化界面：** 避免不必要的配置项
3. **一致性：** 保持租户名称与用户昵称的关联

**如果需要修改租户名称：**
- **方法1（推荐）：** 修改用户昵称，租户名称会相应变化（如果系统支持）
- **方法2：** 直接修改数据库 `tenant` 表的 `name` 字段
- **方法3：** 扩展后端API，添加租户名称更新功能

### 创建新租户

**重要：** 系统设计为每个用户只有一个自己创建的租户（工作空间）。

**设计原因：**
1. **简化模型：** 一个用户对应一个主工作空间
2. **资源隔离：** 每个租户拥有独立的资源和配置
3. **多租户支持：** 用户可以通过加入其他租户来访问多个工作空间

**用户如何获得多个工作空间？**
- ✅ 创建自己的租户（注册时自动创建）
- ✅ 加入其他用户的租户（通过邀请）
- ❌ 不能创建第二个自己的租户（系统不支持）

**实际场景：**
- 张三注册后，自动创建了"张三's Kingdom"工作空间
- 张三可以邀请李四加入，李四就成为该工作空间的成员
- 李四注册后，也有自己的"李四's Kingdom"工作空间
- 张三可以加入李四的工作空间，这样张三就有两个工作空间可用

### 总结

| 功能 | 是否支持 | 说明 |
|------|---------|------|
| 自动创建租户 | ✅ | 用户注册时自动创建 |
| 查看租户信息 | ✅ | 通过 `/user/tenant_info` API |
| 编辑模型配置 | ✅ | 通过 `/user/set_tenant_info` API 和前端模型配置页面 |
| 编辑租户名称 | ❌ | 前端和后端都不支持 |
| 创建新租户 | ❌ | 每个用户只能有一个自己创建的租户 |
| 加入其他租户 | ✅ | 通过邀请机制加入其他用户的工作空间 |

---

## 邀请用户与角色管理

### 邀请用户流程

#### 1. 发送邀请

**前端操作：**
- 路径：个人信息设置页 → 团队管理 → 邀请成员
- 界面：只要求输入用户邮箱，**没有角色选择选项**

**后端处理：**
- **API路径：** `POST /api/v1/tenant/<tenant_id>/user`
- **权限要求：** 只有租户的 owner 可以邀请用户（`current_user.id == tenant_id`）
- **默认角色：** 固定设置为 `invite`（待接受状态）

**代码实现：**
```python
# api/apps/tenant_app.py
@manager.route('/<tenant_id>/user', methods=['POST'])
@login_required
async def create(tenant_id):
    # 1. 权限检查：只有owner可以邀请
    if current_user.id != tenant_id:
        return get_json_result(
            data=False,
            message='No authorization.',
            code=RetCode.AUTHENTICATION_ERROR
        )
    
    # 2. 查找用户
    invite_user_email = req["email"]
    invite_users = UserService.query(email=invite_user_email)
    
    # 3. 检查用户是否已在团队中
    user_tenants = UserTenantService.query(
        user_id=user_id_to_invite, 
        tenant_id=tenant_id
    )
    if user_tenants:
        # 如果已经是normal，提示已在团队中
        if user_tenant_role == UserTenantRole.NORMAL:
            return get_data_error_result(
                message=f"{invite_user_email} is already in the team."
            )
    
    # 4. 创建邀请记录，角色固定为 INVITE
    UserTenantService.save(
        id=get_uuid(),
        user_id=user_id_to_invite,
        tenant_id=tenant_id,
        invited_by=current_user.id,
        role=UserTenantRole.INVITE,  # ⚠️ 固定为 INVITE
        status=StatusEnum.VALID.value
    )
```

**关键点：**
- ❌ **前端没有角色选择功能**：邀请时只能输入邮箱
- ❌ **后端不接受角色参数**：API只接受 `email` 参数
- ✅ **默认角色固定为 `invite`**：所有邀请都从 `invite` 状态开始

#### 2. 接受邀请

**前端操作：**
- 路径：个人信息设置页 → 已加入的团队
- 界面：显示待接受的邀请，点击"接受"按钮

**后端处理：**
- **API路径：** `PUT /api/v1/tenant/agree/<tenant_id>`
- **默认角色：** 固定设置为 `normal`（普通成员）

**代码实现：**
```python
# api/apps/tenant_app.py
@manager.route("/agree/<tenant_id>", methods=["PUT"])
@login_required
def agree(tenant_id):
    # 接受邀请，角色固定改为 NORMAL
    UserTenantService.filter_update(
        [
            UserTenant.tenant_id == tenant_id, 
            UserTenant.user_id == current_user.id
        ],
        {"role": UserTenantRole.NORMAL}  # ⚠️ 固定改为 NORMAL
    )
    return get_json_result(data=True)
```

**关键点：**
- ❌ **接受邀请后固定为 `normal`**：无法在接受时选择其他角色
- ❌ **没有参数可以设置角色**：API不接受角色参数

### 角色管理现状

#### 当前限制

| 操作 | 前端支持 | 后端支持 | 说明 |
|------|---------|---------|------|
| 邀请时选择角色 | ❌ | ❌ | 固定为 `invite` |
| 接受时选择角色 | ❌ | ❌ | 固定为 `normal` |
| 邀请后修改角色 | ❌ | ❌ | **没有找到相关API** |
| 设置为 admin | ❌ | ❌ | **系统不支持** |

#### 实际流程

```
1. Owner 邀请用户
   └─→ 角色固定为: INVITE

2. 用户接受邀请
   └─→ 角色固定改为: NORMAL

3. 如果需要设置为 Admin
   └─→ ❌ 当前系统不支持此功能
```

### 如何设置用户为 Admin？

**当前系统限制：**
- ❌ 前端没有设置 admin 的界面
- ❌ 后端没有设置 admin 的 API 接口
- ❌ 邀请和接受流程都不支持角色选择

**可能的解决方案：**

**方案1：直接修改数据库（不推荐）**
```sql
-- 将用户角色从 normal 改为 admin
UPDATE user_tenant 
SET role = 'admin' 
WHERE user_id = 'user_id' AND tenant_id = 'tenant_id';
```

**方案2：扩展后端API（推荐）**
需要添加新的API接口来更新用户角色：
```python
# 建议添加的API
@manager.route('/<tenant_id>/user/<user_id>/role', methods=['PUT'])
@login_required
async def update_user_role(tenant_id, user_id):
    # 只有owner可以修改角色
    if current_user.id != tenant_id:
        return get_json_result(
            data=False,
            message='No authorization.',
            code=RetCode.AUTHENTICATION_ERROR
        )
    
    req = await get_request_json()
    new_role = req.get("role")  # admin 或 normal
    
    # 验证角色
    if new_role not in [UserTenantRole.ADMIN, UserTenantRole.NORMAL]:
        return get_data_error_result(message="Invalid role.")
    
    # 不能将owner改为其他角色
    existing = UserTenantService.query(
        user_id=user_id, 
        tenant_id=tenant_id
    )[0]
    if existing.role == UserTenantRole.OWNER:
        return get_data_error_result(
            message="Cannot change owner role."
        )
    
    # 更新角色
    UserTenantService.filter_update(
        [
            UserTenant.tenant_id == tenant_id,
            UserTenant.user_id == user_id
        ],
        {"role": new_role}
    )
    
    return get_json_result(data=True)
```

**方案3：扩展前端界面**
在团队成员列表中，为每个成员添加"设置角色"功能：
- Owner 可以看到"设置为管理员"或"设置为普通成员"的选项
- 点击后调用后端API更新角色

### 总结

**当前系统的角色管理特点：**

1. **邀请流程：**
   - 前端：只输入邮箱，无角色选择
   - 后端：固定设置为 `invite`

2. **接受流程：**
   - 前端：只显示"接受"按钮，无角色选择
   - 后端：固定设置为 `normal`

3. **角色升级：**
   - ❌ 系统不支持将 `normal` 升级为 `admin`
   - ❌ 没有相关的API接口
   - ❌ 前端没有相关界面

4. **设计原因（推测）：**
   - 简化用户流程：避免邀请时的复杂选择
   - 安全考虑：防止误操作导致权限过大
   - 后续扩展：可能需要通过其他方式（如工作流、审批）来设置 admin

**建议：**
如果需要设置 admin 角色，可以考虑：
1. 扩展后端API，添加角色更新接口
2. 扩展前端界面，添加角色管理功能
3. 或者通过数据库直接修改（临时方案）

---

## 常见问题与排查

### 问题1：用户无法访问知识库

**症状：** 用户登录后，看不到某些知识库。

**排查步骤：**

1. **检查用户是否属于知识库的租户**
```python
# 查询UserTenant表
user_tenants = UserTenantService.query(user_id="user@example.com")
tenant_ids = [ut.tenant_id for ut in user_tenants]

# 检查知识库的tenant_id是否在列表中
kb = KnowledgebaseService.get_by_id("kb_001")
if kb.tenant_id not in tenant_ids:
    print("用户不属于该租户")
```

2. **检查知识库的权限设置**
```python
kb = KnowledgebaseService.get_by_id("kb_001")
print(f"知识库权限: {kb.permission}")

if kb.permission == "me":
    # 只有创建者可以访问
    if kb.tenant_id != user_id:
        print("知识库是私有的，用户不是创建者")
```

3. **检查用户角色**
```python
user_tenant = UserTenantService.query(
    user_id="user@example.com",
    tenant_id="dev_team_001"
)

if user_tenant.role == "invite":
    print("用户尚未接受邀请，无访问权限")
```

### 问题2：API Token无效

**症状：** 使用API Token访问接口时返回认证错误。

**排查步骤：**

1. **检查Token格式**
```python
# 正确的格式
headers = {
    "Authorization": "Bearer api_token_12345"  # 注意Bearer和token之间有空格
}

# 错误的格式
headers = {
    "Authorization": "api_token_12345"  # 缺少Bearer前缀
}
```

2. **检查Token是否存在**
```python
# 查询APIToken表
tokens = APIToken.query(token="api_token_12345")
if not tokens:
    print("Token不存在或已失效")
```

3. **检查Token关联的租户**
```python
token = APIToken.query(token="api_token_12345")[0]
print(f"Token关联的租户: {token.tenant_id}")

# 确认租户状态
tenant = TenantService.get_by_id(token.tenant_id)
if tenant.status != "1":
    print("租户已被禁用")
```

### 问题3：超级用户无法访问资源

**症状：** 设置了 `is_superuser=True` 但仍然无法访问某些资源。

**排查步骤：**

1. **确认is_superuser字段值**
```python
user = UserService.get_by_id("admin@ragflow.io")
print(f"is_superuser: {user.is_superuser}")  # 应该是True

# 如果为False，需要更新
UserService.update(
    user_id="admin@ragflow.io",
    is_superuser=True
)
```

2. **检查权限检查代码是否包含超级用户判断**
```python
# 正确的权限检查应该包含超级用户判断
def check_permission(user, resource):
    if user.is_superuser:
        return True  # 超级用户直接通过
    
    # ... 其他权限检查逻辑
```

### 问题4：用户角色不生效

**症状：** 修改了UserTenant表的role字段，但权限没有变化。

**排查步骤：**

1. **检查UserTenant的status字段**
```python
user_tenant = UserTenantService.query(
    user_id="user@example.com",
    tenant_id="dev_team_001"
)

if user_tenant.status != "1":
    print("用户-租户关系已被禁用，需要启用")
    UserTenantService.update(
        user_tenant_id=user_tenant.id,
        status="1"
    )
```

2. **检查用户状态**
```python
user = UserService.get_by_id("user@example.com")

if user.status != "1":
    print("用户已被禁用")
if user.is_active != "1":
    print("用户不活跃")
```

### 问题5：文件权限检查失败

**症状：** 用户有权限访问知识库，但无法访问其中的文件。

**排查步骤：**

1. **检查文件是否属于知识库**
```python
# 查询文件所属的知识库
kb_ids = FileService.get_kb_id_by_file_id("file_001")
print(f"文件所属的知识库: {kb_ids}")

if not kb_ids:
    print("文件不属于任何知识库")
```

2. **检查知识库权限**
```python
for kb_id in kb_ids:
    ok, kb = KnowledgebaseService.get_by_id(kb_id)
    if not ok:
        continue
    
    # 检查知识库权限
    has_permission = check_kb_team_permission(kb, user_id)
    if has_permission:
        print(f"用户有权限访问知识库 {kb_id}")
        break
else:
    print("用户无权限访问文件所属的任何知识库")
```

---

## 总结

RAGFlow 的权限管理系统通过以下机制实现了细粒度的访问控制：

1. **多租户隔离**：每个租户拥有独立的资源和配置
2. **角色分级**：owner、admin、normal、invite 四个角色层级
3. **资源权限标记**：me（仅自己）和 team（团队共享）两种权限模式
4. **超级用户旁路**：is_superuser 用户可跨租户访问所有资源
5. **API Token认证**：支持程序化访问

在实际使用中，需要注意：
- 用户必须属于租户才能访问租户资源
- invite 角色的用户无实际访问权限
- 文件权限继承自所属知识库的权限
- 超级用户可以绕过所有权限检查

通过合理配置用户、租户、角色和资源权限，可以实现灵活的权限管理，满足不同场景下的访问控制需求。

